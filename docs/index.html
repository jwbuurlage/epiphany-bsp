

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59249373-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Epiphany BSP 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html#document-index" class="icon icon-home"> Epiphany BSP
          

          
            
            <img src="_static/coduin_logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><p class="caption"><span class="caption-text">User Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-introduction">Introduction and Setting up</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#making-an-ebsp-project">Making an EBSP Project</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-basic">Getting started: The Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#hello-world">Hello World!</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface-basics">Interface (Basics)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-variables">BSP Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#registering-putting-and-getting">Registering, putting and getting</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface-variables">Interface (Variables)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-mp">Message Passing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#sending-and-receiving-messages">Sending and receiving messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface-messages">Interface (Messages)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-host_client">Communicating with the Epiphany</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#communication-up-and-down">Communication: up and down</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface-vertical-communication">Interface (Vertical communication)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-streaming">Data streams</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#streaming">Streaming</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface">Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-other_features">Other features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#timers">Timers</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interrupts">Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#callbacks">Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface-timer-and-callback">Interface (Timer and callback)</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Support Library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-output">Output</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface">Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-memory_management">Memory Management</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#data-copying">Data copying</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#interface">Interface</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reference &amp; Background</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-memory_details">Parallella Memory Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-bsp">BSP Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_reference">API Reference</a></li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html#document-index">Epiphany BSP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html#document-index">Docs</a> &raquo;</li>
        
      <li>Epiphany BSP 1.0 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="welcome-to-epiphany-bsp-s-documentation">
<h1>Welcome to Epiphany BSP’s documentation!<a class="headerlink" href="#welcome-to-epiphany-bsp-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Epiphany BSP is a library for developing applications for the <a class="reference external" href="https://www.parallella.org">Parallella board</a>. It is easy to setup and use, and provides powerful mechanisms for writing optimized parallel programs.</p>
<p>This documentation provides an introduction to each component of the
Epiphany BSP (EBSP) library. Each section introduces a number of new EBSP functions
which we call <em>primitives</em> through an example. At the end of each section the
new primitives are summarized and detailed documentation is provided for them. After reading only a couple of sections you will be able to write simple programs for the Parallella.
We also provide a complete reference of the API and a short introduction to the formal BSP model.</p>
<p>The EBSP library is released under the LGPLv3. The <a class="reference external" href="https://github.com/coduin/epiphany-bsp">source code</a> and <a class="reference external" href="https://github.com/coduin/epiphany-bsp/issues">issue tracker</a> are both hosted on GitHub. The latest <a class="reference external" href="http://www.github.com/coduin/epiphany-bsp/releases">EBSP release</a> is 1.0.</p>
<hr class="docutils" />
<div class="section" id="about-coduin">
<h2>About Coduin<a class="headerlink" href="#about-coduin" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://codu.in">Coduin</a> (formerly Buurlage Wits) is a small company based in Utrecht, the Netherlands. Next to our work on software libraries and models for many-core processors in embedded systems, we are also active in the area of data analysis and predictive modelling.</p>
<a class="reference internal image-reference" href="_images/coduin_logo.png"><img alt="_images/coduin_logo.png" class="align-center" src="_images/coduin_logo.png" style="width: 250px;" /></a>
<p>If you are using EBSP, or have any questions, remarks or ideas then please get in touch at <a class="reference external" href="mailto:info&#37;&#52;&#48;buurlagewits&#46;nl">info<span>&#64;</span>buurlagewits<span>&#46;</span>nl</a>! We would very much like to hear from you.</p>
<hr class="docutils" />
<div class="toctree-wrapper compound">
<span id="document-introduction"></span><div class="section" id="introduction-and-setting-up">
<h3>Introduction and Setting up<a class="headerlink" href="#introduction-and-setting-up" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Bulk_synchronous_parallel">BSP</a> (Bulk Synchronous Parallel) computing model is a model for designing parallel algorithms. It provides
a description of how parallel computation should be
carried out. Programs written with this model consist of
a number of supersteps, which in turn consist of local
computations and non-blocking communication. A (barrier)
synchronisation at the end of such a step is used to guarantee
occurance of all communications within a step. The BSP model can be used to write portable and powerful parallel applications.</p>
<a class="reference internal image-reference" href="_images/epiphany-bsp-illustration-trimmed-small.jpg"><img alt="_images/epiphany-bsp-illustration-trimmed-small.jpg" class="align-center" src="_images/epiphany-bsp-illustration-trimmed-small.jpg" style="width: 450px;" /></a>
<p>Our library (EBSP) provides an implementation of the model on top of the Epiphany SDK (ESDK).
This allows the BSP computing model to be used with the Epiphany
architecture developed by <a class="reference external" href="http://www.adapteva.com">Adapteva</a>.
In particular EBSP has been implemented and tested on the
<a class="reference external" href="http://www.parallella.org">Parallella</a> board. Our goal is to
allow current BSP programs to be run on the Epiphany architecture
with minimal modifications.</p>
<p>We believe the BSP model is a good starting point
for anyone new to parallel algorithms, and our goal for this library is to provide an easy way
to implement parallel programs on the Epiphany architecture, without having to resort directly
to the Epiphany SDK. This documentation aims to provide both an introduction to the library and BSP
programming in general. It should also be a very useful reference when programming using EBSP.</p>
<div class="section" id="making-an-ebsp-project">
<h4>Making an EBSP Project<a class="headerlink" href="#making-an-ebsp-project" title="Permalink to this headline">¶</a></h4>
<p>If you want to write EBSP programs you need to have access to a <a class="reference external" href="http://www.parallella.org">Parallella</a> board with a recent version of the Epiphany SDK (ESDK) installed. If you want to read this documentation as a tutorial, it is perhaps easiest to clone the <a class="reference external" href="https://github.com/coduin/ebsp-empty-project">EBSP example project</a> found on GitHub using <code class="docutils literal notranslate"><span class="pre">git</span></code>. The empty project template is organized as follows:</p>
<div class="highlight-Makefile notranslate"><div class="highlight"><pre><span></span>../project
├── bin
├── ext
│   └── bsp
│   │   ├── include
│   │   │   ├── e_bsp.h
│   │   │   └── host_bsp.h
│   │   └── lib
│   │       ├── e_bsp.a
│   │       └── host_bsp.a
│   └── ebsp_fast.ldf
├── Makefile
└─── src
    ├── ecore_code.c
    └── host_code.c
</pre></div>
</div>
<p>If you just want to toy with the library, we suggest you use the example project, and write the code in <code class="docutils literal notranslate"><span class="pre">src/ecore_code.c</span></code> and <code class="docutils literal notranslate"><span class="pre">src/host_code.c</span></code>. To (re)build the program issue <code class="docutils literal notranslate"><span class="pre">make</span></code> from the command-line and afterwards run <code class="docutils literal notranslate"><span class="pre">bin/host_program</span></code>.</p>
<p>For more advanced use you can download the latest EBSP release from the <a class="reference external" href="https://github.com/coduin/epiphany-bsp/releases">release page on GitHub</a>. The EBSP library depends on the ESDK, and uses a custom linker file. If you want to use EBSP directly, without using the empty project as a template, we provide you with an example Makefile below which you can adapt for your own project:</p>
<div class="highlight-Makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">ESDK</span><span class="o">=</span><span class="si">${</span><span class="nv">EPIPHANY_HOME</span><span class="si">}</span>
<span class="nv">ELDF</span><span class="o">=</span>ext/bsp/ebsp_fast.ldf

<span class="nv">CFLAGS</span><span class="o">=</span>-std<span class="o">=</span>c99 -O3 -ffast-math -Wall

<span class="nv">INCLUDES</span> <span class="o">=</span> -Iext/bsp/include <span class="se">\</span>
           -I<span class="si">${</span><span class="nv">ESDK</span><span class="si">}</span>/tools/host/include

<span class="nv">HOST_LIBS</span> <span class="o">=</span> -Lext/bsp/lib <span class="se">\</span>
            -L<span class="si">${</span><span class="nv">ESDK</span><span class="si">}</span>/tools/host/lib <span class="se">\</span>
            -L/usr/arm-linux-gnueabihf/lib

<span class="nv">E_LIBS</span> <span class="o">=</span> -Lext/bsp/lib <span class="se">\</span>
         -L<span class="si">${</span><span class="nv">ESDK</span><span class="si">}</span>/tools/host/lib

<span class="nv">HOST_LIB_NAMES</span> <span class="o">=</span> -lhost-bsp -le-hal -le-loader

<span class="nv">E_LIB_NAMES</span> <span class="o">=</span> -le-bsp -le-lib

<span class="nf">all</span><span class="o">:</span> <span class="n">bin</span> <span class="n">bin</span>/<span class="n">host_program</span> <span class="n">bin</span>/<span class="n">ecore_program</span>.<span class="n">srec</span>

<span class="nf">bin</span><span class="o">:</span>
    @mkdir -p bin

<span class="nf">bin/host_program</span><span class="o">:</span> <span class="n">src</span>/<span class="n">host_code</span>.<span class="n">c</span>
    @echo <span class="s2">&quot;CC </span>$<span class="s2">&lt;&quot;</span>
    @gcc <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="k">$(</span>INCLUDES<span class="k">)</span> -o <span class="nv">$@</span> $&lt; <span class="k">$(</span>HOST_LIBS<span class="k">)</span> <span class="k">$(</span>HOST_LIB_NAMES<span class="k">)</span>

<span class="nf">bin/ecore_program.elf</span><span class="o">:</span> <span class="n">src</span>/<span class="n">ecore_code</span>.<span class="n">c</span>
    @echo <span class="s2">&quot;CC </span>$<span class="s2">&lt;&quot;</span>
    @e-gcc <span class="k">$(</span>CFLAGS<span class="k">)</span> -T <span class="si">${</span><span class="nv">ELDF</span><span class="si">}</span> <span class="k">$(</span>INCLUDES<span class="k">)</span> -o <span class="nv">$@</span> $&lt; <span class="k">$(</span>E_LIBS<span class="k">)</span> <span class="k">$(</span>E_LIB_NAMES<span class="k">)</span>

<span class="nf">bin/%.srec</span><span class="o">:</span> <span class="n">bin</span>/%.<span class="n">elf</span>
    @e-objcopy --srec-forceS3 --output-target srec $&lt; <span class="nv">$@</span>

<span class="nf">clean</span><span class="o">:</span>
    rm -r bin
</pre></div>
</div>
</div>
</div>
<span id="document-basic"></span><div class="section" id="getting-started-the-basics">
<h3>Getting started: The Basics<a class="headerlink" href="#getting-started-the-basics" title="Permalink to this headline">¶</a></h3>
<p>EBSP programs are written in <em>SPMD</em> (single-program multiple-data) style. This means that each core runs the same code, but obtains different data. Later we will see how we can transfer data to and from the Epiphany cores, but for now our first step will be to get the cores to output their designated core number (called <code class="docutils literal notranslate"><span class="pre">pid</span></code> for <em>processor identifier</em>). Like all programs written for the Parallella, an EBSP program consists of two parts. One part contains the code that runs on the <em>host processor</em>, the ARM chip that hosts the Linux OS. The other part contains the code that runs on each Epiphany core. In heterogeneous computing it is common to call this second part the <em>kernel</em>.</p>
<div class="section" id="hello-world">
<h4>Hello World!<a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h4>
<p>A host program consists of at least four EBSP functions, which are generally used as in the following example::</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: host_code.c</span>

<span class="cp">#include</span> <span class="cpf">&lt;host_bsp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;ecore_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">bsp_begin</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="n">ebsp_spmd</span><span class="p">();</span>
    <span class="n">bsp_end</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first call to <code class="docutils literal notranslate"><span class="pre">bsp_init</span></code> initializes the EBSP library. The first argument is the filename of the (compiled) kernel program, and the second and third arguments are the program arguments. Next we tell the EBSP system how many cores we would like to use (in this case; all 16 cores for a standard Parallella board) by calling <code class="docutils literal notranslate"><span class="pre">bsp_begin</span></code> passing <code class="docutils literal notranslate"><span class="pre">16</span></code> as its first argument. The call to <code class="docutils literal notranslate"><span class="pre">ebsp_spmd</span></code> starts the execution of the kernel program on the 16 cores. When the execution has finished we finalize the EBSP system by calling <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code> without arguments.</p>
<p>Next we write the kernel for our Hello World program. Besides outputting “Hello World” we also show the processor number. The code looks like this::</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: ecore_code.c</span>

<span class="cp">#include</span> <span class="cpf">&lt;e_bsp.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">bsp_begin</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>
    <span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;Hello World from processor %d / %d&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="n">bsp_end</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let us also go over the kernel code line by line. First we initialize the EBSP system on the core, by calling <code class="docutils literal notranslate"><span class="pre">bsp_begin</span></code>. In a kernel program this call does not require any arguments, since there is no additional program to run! Next we obtain information about our own designated processor number (commonly called <code class="docutils literal notranslate"><span class="pre">s</span></code>) using <code class="docutils literal notranslate"><span class="pre">bsp_pid</span></code>, and the total number of processors (commonly called <code class="docutils literal notranslate"><span class="pre">p</span></code>) by calling <code class="docutils literal notranslate"><span class="pre">bsp_nprocs</span></code>. We then output a message to host using <code class="docutils literal notranslate"><span class="pre">ebsp_message</span></code>. This function can be used completely identically to <code class="docutils literal notranslate"><span class="pre">printf</span></code> in ordinary C programs. Again we finalize the system with a call to <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code> which cleans up the EBSP system.</p>
<p>You may have noticed that some EBSP functions, which we will refer to as <em>primitives</em>, are prefixed with <code class="docutils literal notranslate"><span class="pre">bsp_</span></code> while others are prefixed by <code class="docutils literal notranslate"><span class="pre">ebsp_</span></code>. This is because the EBSP library introduces some functions that are not in the <a class="reference external" href="http://www.bsp-worldwide.org/">BSPlib standard</a> but that can be very helpful when programming for the Epiphany.</p>
<p>Running this program should result in output similar to the following::</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$08: Hello World from processor 8 / 16
$01: Hello World from processor 1 / 16
$07: Hello World from processor 7 / 16
$02: Hello World from processor 2 / 16
$15: Hello World from processor 15 / 16
$03: Hello World from processor 3 / 16
$10: Hello World from processor 10 / 16
$06: Hello World from processor 6 / 16
$12: Hello World from processor 12 / 16
$13: Hello World from processor 13 / 16
$05: Hello World from processor 5 / 16
$04: Hello World from processor 4 / 16
$11: Hello World from processor 11 / 16
$14: Hello World from processor 14 / 16
$09: Hello World from processor 9 / 16
$00: Hello World from processor 0 / 16
</pre></div>
</div>
<p>The output has the form <code class="docutils literal notranslate"><span class="pre">$[pid]:</span> <span class="pre">output</span></code>. As we see, indeed the EBSP kernel is being run on every core! Note that there are no guarantees about which core gets to the <code class="docutils literal notranslate"><span class="pre">ebsp_message</span></code> statement first, and therefore the output need not be in order of processor number.</p>
</div>
<div class="section" id="interface-basics">
<h4>Interface (Basics)<a class="headerlink" href="#interface-basics" title="Permalink to this headline">¶</a></h4>
<div class="section" id="host">
<h5>Host<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_initPKciPPc">
<span id="_CPPv28bsp_initPKciPPc"></span><span id="bsp_init__cCP.i.cPP"></span><span class="target" id="host__bsp_8h_1a0e3c4e8b772e2ed3d8b231289d694e9c"></span>int <code class="descname">bsp_init</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>e_name</em>, int <em>argc</em>, char **<em>argv</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initializes the BSP system. </p>
<p><p>Sets up all the BSP variables and loads the epiphany BSP program.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e_name</span></code>: A string with the srec binary name of the Epiphany program </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: The number of input arguments </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: An array of strings with the input arguments </li>
</ul>
</dd>
</dl>
</p>
<p>The string <code class="docutils literal notranslate"><span class="pre">e_name</span></code> must be of the form <code class="docutils literal notranslate"><span class="pre">myprogram.srec</span></code>. This function will search for the file in the same directory as the host program, and not in the current working directory.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">argc</span></code> and <code class="docutils literal notranslate"><span class="pre">argv</span></code> parameters are ignored in the current implementation. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_begini">
<span id="_CPPv29bsp_begini"></span><span id="bsp_begin__i"></span><span class="target" id="host__bsp_8h_1a6e8b0d677de36ad531e72b212e45f14e"></span>int <code class="descname">bsp_begin</code><span class="sig-paren">(</span>int <em>nprocs</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Loads the BSP program onto the Epiphany cores. </p>
<p><p>Usage example: </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">bsp_begin</span><span class="p">(</span><span class="n">bsp_nprocs</span><span class="p">());</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nprocs</span></code>: The number of processors to run on </li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The current implementation only allows <code class="docutils literal notranslate"><span class="pre">nprocs</span></code> to be a multiple of 4 on the 16-core Parallella. Other values of <code class="docutils literal notranslate"><span class="pre">nprocs</span></code> are rounded down. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39ebsp_spmdv">
<span id="_CPPv29ebsp_spmdv"></span><span id="ebsp_spmd"></span><span class="target" id="host__bsp_8h_1a12385c882b6096484952fe7acad958bd"></span>int <code class="descname">ebsp_spmd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Runs the Epiphany program on the Epiphany cores. </p>
<p><p>This function will block until the BSP kernel program is finished. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure (e.g. after <code class="docutils literal notranslate"><span class="pre">bsp_abort</span></code> is called on a core)</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_endv">
<span id="_CPPv27bsp_endv"></span><span id="bsp_end"></span><span class="target" id="host__bsp_8h_1a56a290cf0e1b78c832024cd5399f46d0"></span>int <code class="descname">bsp_end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Finalizes and cleans up the BSP program. </p>
<p><p>Usage example: </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">bsp_begin</span><span class="p">(</span><span class="n">bsp_nprocs</span><span class="p">());</span>
    <span class="n">ebsp_spmd</span><span class="p">();</span>
    <span class="n">bsp_end</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function is different from the bsp_end function in e_bsp.h </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_beginv">
<span id="_CPPv29bsp_beginv"></span><span id="bsp_begin"></span><span class="target" id="e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"></span>void <code class="descname">bsp_begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_beginv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Denotes the start of a BSP program. </p>
<p>This initializes the BSP system on the core.</p>
<p>Must be called before calling any other BSP function. Should only be called once in a program. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_pidv">
<span id="_CPPv27bsp_pidv"></span><span id="bsp_pid"></span><span class="target" id="e__bsp_8h_1a1e4f897e62f8b20a7f57cc5488bfb8c8"></span>int <code class="descname">bsp_pid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the processor identifier of the local core. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An integer with the id of the core The processor id is an integer in the range [0, .., <a class="reference internal" href="index.html#e__bsp_8h_1a8980a3403ba99114626b34492b13c1cd"><span class="std std-ref">bsp_nprocs()</span></a> - 1]. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv310bsp_nprocsv">
<span id="_CPPv210bsp_nprocsv"></span><span id="bsp_nprocs"></span><span class="target" id="e__bsp_8h_1a8980a3403ba99114626b34492b13c1cd"></span>int <code class="descname">bsp_nprocs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the number of Epiphany cores currently in use. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An integer indicating the number of cores on which the program runs. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_endv">
<span id="_CPPv27bsp_endv"></span><span class="target" id="e__bsp_8h_1ad794334e180b711537499871020a76fe"></span>void <code class="descname">bsp_end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Denotes the end of a BSP program. </p>
<p>Finalizes and cleans up the BSP program. No other BSP functions are allowed to be called after this function is called.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Must be followed by a return statement in your main function if you want to call <code class="docutils literal notranslate"><span class="pre">ebsp_spmd()</span></code> multiple times. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv312ebsp_messagePKcz">
<span id="_CPPv212ebsp_messagePKcz"></span><span id="ebsp_message__cCP.z"></span><span class="target" id="e__bsp_8h_1ad3a2c88749e9dab3e73b9923a5b86add"></span>void <code class="descname">ebsp_message</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv312ebsp_messagePKcz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Output a debug message printf style. </p>
<p><a class="reference internal" href="index.html#e__bsp_8h_1ad3a2c88749e9dab3e73b9923a5b86add"><span class="std std-ref">ebsp_message()</span></a> outputs a debug message by sending it to shared memory So that the host processor can output it to the terminal The attributes in this definition make sure that the compiler checks the arguments for errors. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">format</span></code>: The formatting string in printf style</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
<span id="document-variables"></span><div class="section" id="bsp-variables">
<h3>BSP Variables<a class="headerlink" href="#bsp-variables" title="Permalink to this headline">¶</a></h3>
<div class="section" id="registering-putting-and-getting">
<h4>Registering, putting and getting<a class="headerlink" href="#registering-putting-and-getting" title="Permalink to this headline">¶</a></h4>
<p>If we want to write more interesting EBSP programs, we need to have a way to communicate between the different Epiphany cores. In EBSP communication happens in one of two ways: using message passing, which we will introduce later, or via <em>registered variables</em>. An EBSP variable exists on every processor, but does not necessarily have the same size on every Epiphany core.</p>
<div class="section" id="variable-registration">
<h5>Variable registration<a class="headerlink" href="#variable-registration" title="Permalink to this headline">¶</a></h5>
<p>We register a variable by calling <code class="docutils literal notranslate"><span class="pre">bsp_push_reg</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>Here we declare an integer <code class="docutils literal notranslate"><span class="pre">a</span></code>, and initialize it with zero. Next we <em>register</em> the variable with the BSP system, by passing its local location, and its size.</p>
<p>To ensure that all cores have registered a variable, we perform a barrier synchronisation after the registration. The Epiphany cores will halt execution until <em>every other core</em> reaches this point in the program, so it <em>synchronizes</em> the program execution between the Epiphany cores. Only <em>one variable may be declared between calls to</em> <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>!</p>
</div>
<div class="section" id="putting-and-getting-values">
<h5>Putting and getting values<a class="headerlink" href="#putting-and-getting-values" title="Permalink to this headline">¶</a></h5>
<p>Registered variables can be written to or be read from by other cores. In BSP this is referred to as <em>putting</em> something in a variable, or <em>getting</em> the value of a variable. To write for example our processor ID to the <em>next core</em> we can write:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_put</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>Let us explain this code line by line. As in the <em>Hello World</em> example, here we define <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> to be the processor id and the number of processors respectively. In our call to <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> we pass the following arguments (in order):</p>
<ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> of the target (i.e. the receiving) processor.</li>
<li>A pointer to the source data that we want to copy to the target processor.</li>
<li>A pointer representing a <em>registered variable</em>. Note that this pointer refers to the registered variable on the <em>sending</em> processor – the EBSP system can identify these processors such that it knows which <em>remote address</em> to write to.</li>
<li>The offset (in bytes) from which we want to start writing at the target processor.</li>
<li>The number of bytes to copy.</li>
</ol>
<p>Before we want to use a communicated value on the target processor, we need to again perform a barrier synchronisation by calling <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>. This ensures that all the outstanding communication gets resolved. After the call to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> returns, we can use the result of <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> on the target processor. The code between two consecutive calls to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> is called a <em>superstep</em>.</p>
<p>When we receive the data, we can for example write the result to the standard output. Below we give the complete program which makes use of <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> to communicate with another processor. Here, and in the remainder of this post we will only write the code in between the calls to <code class="docutils literal notranslate"><span class="pre">bsp_begin</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code>, the other code is identical to the code in the <em>Hello World</em> example.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_put</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;received: %i&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>This results in the following output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 0
$02: received: 1
$07: received: 6
$00: received: 15
...
</pre></div>
</div>
<p>Where we have suppressed the output from the other cores. As we see we are correctly receiving the processor id of the previous cores!</p>
<p>An alternative way of communication is <em>getting</em> the value of a registered variable from a remote core. The syntax is very similar:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_get</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>The arguments for <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code> are:</p>
<ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> of processor we want to <em>get</em> the value from.</li>
<li>The pointer representing a registed variable.</li>
<li>The offset (in bytes) at the remote processor from which we want to start reading.</li>
<li>A pointer to the local destination.</li>
<li>The number of bytes to copy.</li>
</ol>
<p>And again, we perform a barrier synchronisation to ensure the data has been transferred. If you are familiar with concurrent programming, then you might think we are at risk of a <a class="reference external" href="https://en.wikipedia.org/wiki/Race_condition">race condition</a>! What if processor <code class="docutils literal notranslate"><span class="pre">s</span></code> reaches the <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code> statement before processor <code class="docutils literal notranslate"><span class="pre">(s</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">%</span> <span class="pre">p</span></code> has set the value for <code class="docutils literal notranslate"><span class="pre">a</span></code> equal to its process number? Do we then obtain zero? In this case, we do not have to worry – no data transfer is initialized until each core has reached <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>. Indeed we receive the correct output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 2
$03: received: 4
$11: received: 12
$14: received: 15
...
</pre></div>
</div>
</div>
<div class="section" id="unbuffered-communication">
<h5>Unbuffered communication<a class="headerlink" href="#unbuffered-communication" title="Permalink to this headline">¶</a></h5>
<p>So far we have discussed writing to, and reading from variables using <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. These two functions are <em>buffered</em>. When calling <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> for example, the <em>current source value</em> at the time of the function call is guarenteed to be sent to the target processor, but it does not get sent until the next barrier synchronisation – so behind the scenes the EBSP library stores a copy of the data. The BSP standard was originally designed for distributed memory systems with very high latency, in which this design makes a lot of sense. On the Epiphany platform this gives a lot of unnecessary overhead since data is copied to <em>external memory</em>.</p>
<p>This problem is not unique to the Epiphany platform however. Together with the <a class="reference external" href="http://www.multicorebsp.com/">MulticoreBSP</a> which targets modern multicore processors, two additional BSP primitives were introduced that provide <em>unbuffered</em> variable communication, <code class="docutils literal notranslate"><span class="pre">bsp_hpput</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_hpget</span></code>. Here the <code class="docutils literal notranslate"><span class="pre">hp...</span></code> prefix stands for <em>high performance</em>.</p>
<p>However, although their function signatures are completely identical, these are not meant as a drop-in replacements for <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. They are unsafe in the sense that data transfer happens <em>at once</em>. This means that when using these functions you should be aware of possible race conditions – which can notoriously lead to mistakes that can be very hard to debug.</p>
<p>To facilitate writing code using only unbuffered communication we introduce a <code class="docutils literal notranslate"><span class="pre">ebsp_barrier</span></code> function that performs a barrier synchronisation without transferring any outstanding communication that has arisen from calls to <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. Let us look at an example program using these unbuffered variants:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="c1">// barrier ensures b has been written to on each core</span>
<span class="n">ebsp_barrier</span><span class="p">();</span>

<span class="n">bsp_hpput</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// barrier ensures data has been received</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;received: %i&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>When writing or reading large amounts of data in between different <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> calls, the <code class="docutils literal notranslate"><span class="pre">hp...</span></code> functions are much more efficient in terms of local memory usage (which is very valuable because of the small size) as well as running speed. However, extra care is needed to effectively synchronize between threads. For example, if we remove either the <code class="docutils literal notranslate"><span class="pre">ebsp_barrier</span></code>, or the  <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> calls in the previous example program, there will be a race condition.</p>
<p>We test the program, and see that the output is indeed identical to before:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 0
$08: received: 7
$02: received: 1
$10: received: 9
...
</pre></div>
</div>
</div>
</div>
<div class="section" id="interface-variables">
<h4>Interface (Variables)<a class="headerlink" href="#interface-variables" title="Permalink to this headline">¶</a></h4>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv312bsp_push_regPKvKi">
<span id="_CPPv212bsp_push_regPKvKi"></span><span id="bsp_push_reg__voidCP.iC"></span><span class="target" id="e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"></span>void <code class="descname">bsp_push_reg</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>variable</em>, <em class="property">const</em> int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Register a variable as available for remote access. </p>
<p><p>The operation takes effect after the next call to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. Only one registration is allowed in a single superstep. When a variable is registered, every core must do so.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">variable</span></code>: A pointer to the local variable </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size in bytes of the variable</li>
</ul>
</dd>
</dl>
</p>
<p>The system maintains a stack of registered variables. Any variables registered in the same superstep are identified with each other. There is a maximum number of allowed registered variables at any given time, the specific number is platform dependent. This limit will be lifted in a future version.</p>
<p>Registering a variable needs to be done before it can be used with the functions <a class="reference internal" href="index.html#e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"><span class="std std-ref">bsp_put()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a>.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>

<span class="c1">// Get the value of the `a` variable of core 0 and save it in `b`</span>
<span class="n">bsp_get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// Save the value of `c` into the array `x` on core 0, at array location p</span>
<span class="n">bsp_put</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>In the current implementation, the parameter nbytes is ignored. In future versions it will be used to make communication more efficient. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_putiPKvPvii">
<span id="_CPPv27bsp_putiPKvPvii"></span><span id="bsp_put__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"></span>void <code class="descname">bsp_put</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data to another processor (buffered). </p>
<p><p>The data in src is copied to a buffer (currently in the inefficient external memory) at the moment bsp_put is called. Therefore the caller can replace the data in src right after bsp_put returns. When </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a> is called, the data will be transferred from the buffer to the destination at the other processor.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to the source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
<dt><strong>Remark</strong></dt>
<dd>The current implementation uses external memory which restrains the performance of this function greatly. We suggest you use <a class="reference internal" href="index.html#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a> wherever possible to ensure good performance. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_getiPKviPvi">
<span id="_CPPv27bsp_getiPKviPvi"></span><span id="bsp_get__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"></span>void <code class="descname">bsp_get</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data from another processor (buffered) </p>
<p><p>No data transaction takes place until the next call to bsp_sync, at which point the data will be copied from source to destination.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The official BSP standard dictates that first all the data of all <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions is copied into a buffer, after which all the data is written to the proper destinations. This would allow one to use bsp_get to swap to variables in place. Because of memory constraints we do not comply with the standard. In our implementation. The <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions are all executed at the same time, therefore such a swap would result in undefined behaviour.</dd>
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv38bsp_syncv">
<span id="_CPPv28bsp_syncv"></span><span id="bsp_sync"></span><span class="target" id="e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"></span>void <code class="descname">bsp_sync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Denotes the end of a superstep, and performs all outstanding communications and registrations. </p>
<p>Serves as a blocking barrier which halts execution until all Epiphany cores are finished with the current superstep.</p>
<p>If only a synchronization is required, and you do not want the outstanding communications and registrations to be resolved, then we suggest you use the more efficient function <a class="reference internal" href="index.html#e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"><span class="std std-ref">ebsp_barrier()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_hpputiPKvPvii">
<span id="_CPPv29bsp_hpputiPKvPvii"></span><span id="bsp_hpput__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"></span>void <code class="descname">bsp_hpput</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data to another processor, unbuffered. </p>
<p><p>The data is immediately copied into the destination at the remote processor, as opposed to bsp_put which first copies the data to a buffer. This means the programmer must make sure that the other processor is not using the destination at this moment. The data transfer is guaranteed to be complete after the next call to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to local source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_hpgetiPKviPvi">
<span id="_CPPv29bsp_hpgetiPKviPvi"></span><span id="bsp_hpget__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"></span>void <code class="descname">bsp_hpget</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data from another processor. </p>
<p>This function is the unbuffered version of <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>. <p>As opposed to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, the data is transferred immediately When <a class="reference internal" href="index.html#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a> is called. When using this function you must make sure that the source data is available and prepared upon calling. For performance reasons, communication using this function should be preferred over buffered communication.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv312ebsp_barrierv">
<span id="_CPPv212ebsp_barrierv"></span><span id="ebsp_barrier"></span><span class="target" id="e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"></span>void <code class="descname">ebsp_barrier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Synchronizes cores without resolving outstanding communication. </p>
<p>This function is more efficient than <a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. </p>
</dd></dl>

</div>
</div>
</div>
<span id="document-mp"></span><div class="section" id="message-passing">
<h3>Message Passing<a class="headerlink" href="#message-passing" title="Permalink to this headline">¶</a></h3>
<div class="section" id="sending-and-receiving-messages">
<h4>Sending and receiving messages<a class="headerlink" href="#sending-and-receiving-messages" title="Permalink to this headline">¶</a></h4>
<p>The next subject we will discuss is <em>passing messages</em> between Epiphany cores. Message passing provides a way to communicate between cores, without having to register variables. This relies on a <em>message queue</em>, which is available to every processor. Using message passing, you can communicate to other cores without registering variables. This can be very useful when the amount of data varies from core to core, and it is not clear beforehand how the data will be distributed. It is good to keep in mind that message passing is a lot slower than alternative communication methods since it utilizes the <em>external memory</em>.</p>
<p>A BSP message has a <em>tag</em> and a <em>payload</em>. The <em>tag</em> identifies the message, and the <em>payload</em> contains the acutal data. The size (in bytes) of a tag is universal, i.e. it is the same across all Epiphany cores (as well as the host). The tagsize can be set using <code class="docutils literal notranslate"><span class="pre">bsp_set_tagsize</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">tagsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">bsp_set_tagsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tagsize</span><span class="p">);</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>The tagsize must be set on each core simultaneously, that is to say in the same <em>superstep</em>. Alternatively, The tagsize can also be set on the host before issuing <code class="docutils literal notranslate"><span class="pre">ebsp_spmd</span></code>. For compatibility reasons, the call to <code class="docutils literal notranslate"><span class="pre">bsp_set_tagsize</span></code> writes the old value for the tagsize to its argument. We also provide an alternative way to obtain the tagsize, by simply calling <code class="docutils literal notranslate"><span class="pre">ebsp_get_tagsize</span></code>.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">tagsize</span> <span class="o">=</span> <span class="n">ebsp_get_tagsize</span><span class="p">();</span>
</pre></div>
</div>
<p>After setting the tagsize (and synchronizing), we are ready to start sending messages. We can send a message using <code class="docutils literal notranslate"><span class="pre">bsp_send</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_send</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>We first need to declare variables holding the tag and the payload. In our case these are integers, but in general you can use any data type. In order, the arguments of <code class="docutils literal notranslate"><span class="pre">bsp_send</span></code> are:</p>
<ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> of processor we want to <em>send</em> the message to.</li>
<li>A pointer to the tag data.</li>
<li>A pointer to the payload data.</li>
<li>The size of the payload. Note that you can vary this size between every send call, contrary to the tagsize.</li>
</ol>
<p>After synchronizing, the target processor can receive the message. To receive messages, we must first inspect the queue:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">accum_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_qsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accum_bytes</span><span class="p">);</span>
</pre></div>
</div>
<p>The call to <code class="docutils literal notranslate"><span class="pre">bsp_qsize</span></code> writes the <em>number of packets</em> to the first argument, and the <em>total number of bytes in the queue</em> to the second argument. Next, we can loop over each packet, <em>moving</em> the packages to the local core:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">payload_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tag_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packets</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bsp_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag_in</span><span class="p">);</span>
    <span class="n">bsp_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;payload: %i, tag: %i&quot;</span><span class="p">,</span> <span class="n">payload_in</span><span class="p">,</span> <span class="n">tag_in</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We use two new primitives here. First we obtain for each packet (note that here we only have a single packet) the payload size and the incoming tag, using <code class="docutils literal notranslate"><span class="pre">bsp_get_tagsize</span></code>. The payload itself is <em>moved</em> using <code class="docutils literal notranslate"><span class="pre">bsp_move</span></code>. The first argument should point to a buffer large enough to store the payload data, and the second argument is the number of bytes to move. Note that we could use our obtained payload size to allocate a buffer large enough to hold the payload, and we could pass it to the second argument of <code class="docutils literal notranslate"><span class="pre">bsp_move</span></code>. It is good to keep in mind that if less bytes are moved than the size of the payload, the remaining data is thrown away. Here we know all messages contain a single integer, such that we can just write the payload into a local variable directly.</p>
<p>This code results in the following output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$02: payload: 43, tag: 1
$08: payload: 49, tag: 1
$00: payload: 57, tag: 1
$13: payload: 54, tag: 1
...
</pre></div>
</div>
<p>Message passing is a very general and powerful technique when using variables to communicate proves to restrictive. However, the flexibility of message passing comes with performance penalty, because the buffers that are involved are too large to store on a single core. As before, <code class="docutils literal notranslate"><span class="pre">bsp_hpput</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_hpget</span></code> should be your preferred way of communicating if you are optimizing for speed.</p>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>We finish our discussion of inter-core BSP message passing by providing a complete program that sends messages around:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">tagsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">bsp_set_tagsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tagsize</span><span class="p">);</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_send</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">accum_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_qsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accum_bytes</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">payload_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tag_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packets</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bsp_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag_in</span><span class="p">);</span>
    <span class="n">bsp_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;payload: %i, tag: %i&quot;</span><span class="p">,</span> <span class="n">payload_in</span><span class="p">,</span> <span class="n">tag_in</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="interface-messages">
<h4>Interface (Messages)<a class="headerlink" href="#interface-messages" title="Permalink to this headline">¶</a></h4>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv315bsp_set_tagsizePi">
<span id="_CPPv215bsp_set_tagsizePi"></span><span id="bsp_set_tagsize__iP"></span><span class="target" id="e__bsp_8h_1a1f711c4d860f03a90257f6072d9e70ec"></span>void <code class="descname">bsp_set_tagsize</code><span class="sig-paren">(</span>int *<em>tag_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the tag size. </p>
<p><p>Upon return, the value pointed to by tag_bytes will contain the old tag size. The new tag size will take effect in the next superstep, so that messages sent in this superstep will have the old tag size. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_bytes</span></code>: A pointer to the tag size, in bytes</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv316ebsp_get_tagsizev">
<span id="_CPPv216ebsp_get_tagsizev"></span><span id="ebsp_get_tagsize"></span><span class="target" id="e__bsp_8h_1a47cf6f4bc4ee48eddc146f52d7eb8f95"></span>int <code class="descname">ebsp_get_tagsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the tag size. </p>
<p><p>This function gets the tag size currently in use. This tagsize remains valid until the start of the next superstep. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The tag size in bytes</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv38bsp_sendiPKvPKvi">
<span id="_CPPv28bsp_sendiPKvPKvi"></span><span id="bsp_send__i.voidCP.voidCP.i"></span><span class="target" id="e__bsp_8h_1a2d79a679686a5357acc6ba936ec60017"></span>void <code class="descname">bsp_send</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>tag</em>, <em class="property">const</em> void *<em>payload</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a message to another processor. </p>
<p><p>This will send a message to the target processor, using the message passing system. The tag size can be obtained by ebsp_get_tagsize. When this function returns, the data has been copied so the user can use the buffer for other purposes. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to the tag data </li>
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the data payload</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_qsizePiPi">
<span id="_CPPv29bsp_qsizePiPi"></span><span id="bsp_qsize__iP.iP"></span><span class="target" id="e__bsp_8h_1ae2fc27ea113832763a241d165e3ea30c"></span>void <code class="descname">bsp_qsize</code><span class="sig-paren">(</span>int *<em>packets</em>, int *<em>accum_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain The number of messages in the queue and the combined size in bytes of their data. </p>
<p><p>Upon return, the integers pointed to by packets and accum_bytes will hold the number of messages in the queue, and the sum of the sizes of their data payloads respectively. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">packets</span></code>: A pointer to an integer which will be overwritten with the number of messages </li>
<li><code class="docutils literal notranslate"><span class="pre">accum_bytes</span></code>: A pointer to an integer which will be overwritten with the combined number of bytes of the message data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv311bsp_get_tagPiPv">
<span id="_CPPv211bsp_get_tagPiPv"></span><span id="bsp_get_tag__iP.voidP"></span><span class="target" id="e__bsp_8h_1a808006e4c1d86e97d8c7a761010fb9e1"></span>void <code class="descname">bsp_get_tag</code><span class="sig-paren">(</span>int *<em>status</em>, void *<em>tag</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the tag and size of the next message without popping the message. </p>
<p><p>Upon return, the integer pointed to by status will receive the size of the data payload in bytes of the next message in the queue. If there is no next message it will be set to -1. The buffer pointed to by tag should be large enough to store the tag. The minimum size can be obtained by calling ebsp_get_tagsize. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">status</span></code>: A pointer to an integer receiving the message data size in bytes. </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to a buffer receiving the message tag</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv38bsp_movePvi">
<span id="_CPPv28bsp_movePvi"></span><span id="bsp_move__voidP.i"></span><span class="target" id="e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"></span>void <code class="descname">bsp_move</code><span class="sig-paren">(</span>void *<em>payload</em>, int <em>buffer_size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the next message from the message queue and pop the message. </p>
<p><p>This will copy the payload and pop the message from the queue. The size of the payload can be obtained by calling </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a808006e4c1d86e97d8c7a761010fb9e1"><span class="std std-ref">bsp_get_tag()</span></a>. If <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> is smaller than the data payload then the data is truncated. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to a buffer receiving the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code>: The size of the buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv310bsp_hpmovePPvPPv">
<span id="_CPPv210bsp_hpmovePPvPPv"></span><span id="bsp_hpmove__voidPP.voidPP"></span><span class="target" id="e__bsp_8h_1a932e0b8b2e82f5ee402adecee0e921dc"></span>int <code class="descname">bsp_hpmove</code><span class="sig-paren">(</span>void **<em>tag_ptr_buf</em>, void **<em>payload_ptr_buf</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the next message, with tag, from the queue and pop the message. </p>
<p><p>This function will give the user direct pointers to the tag and data of the message. This avoids the data copy as done in </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"><span class="std std-ref">bsp_move()</span></a>.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of bytes of the payload data</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_ptr_buf</span></code>: A pointer to a pointer receiving the location of the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">payload_ptr_buf</span></code>: A pointer to a pointer receiving the location of the data pyaload </li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>that both tag and payload can be stored in external memory. Repeated use of these tags will lead to overall worse performance, such that <a class="reference internal" href="index.html#e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"><span class="std std-ref">bsp_move()</span></a> can actually outperform this variant. </dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
<span id="document-host_client"></span><div class="section" id="communicating-with-the-epiphany">
<h3>Communicating with the Epiphany<a class="headerlink" href="#communicating-with-the-epiphany" title="Permalink to this headline">¶</a></h3>
<div class="section" id="communication-up-and-down">
<h4>Communication: up and down<a class="headerlink" href="#communication-up-and-down" title="Permalink to this headline">¶</a></h4>
<p>Writing kernels for the Epiphany is only useful when you can provide them with data to process. The easiest way to send data from the host program running on the host processor to the Epiphany cores is completely analogous to message passing between cores. So far the code we have written on the host only initializes the BSP system, starts the SPMD program on the Epiphany, and finalizes the system afterwards. Before the call to <code class="docutils literal notranslate"><span class="pre">ebsp_spmd</span></code> we can prepare messages containing e.g. initial data for the Epiphany cores. This works completely identically to inter-core message passing, using <code class="docutils literal notranslate"><span class="pre">ebsp_set_tagsize</span></code> instead of <code class="docutils literal notranslate"><span class="pre">bsp_set_tagsize</span></code>, and <code class="docutils literal notranslate"><span class="pre">ebsp_send_down</span></code> instead of <code class="docutils literal notranslate"><span class="pre">bsp_send</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: host_code.c</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">tagsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">ebsp_set_tagsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tagsize</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">ebsp_send_down</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These messages are available like any other on the Epiphany cores, but only between the call to <code class="docutils literal notranslate"><span class="pre">bsp_begin</span></code> and the first call to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>. So on the Epiphany cores we can read the messages using:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: ecore_code.c</span>

<span class="n">bsp_begin</span><span class="p">();</span>

<span class="c1">// here the messages from the host are available</span>
<span class="kt">int</span> <span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">accum_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_qsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accum_bytes</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">payload_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tag_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packets</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bsp_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag_in</span><span class="p">);</span>
    <span class="n">bsp_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;payload: %i, tag: %i&quot;</span><span class="p">,</span> <span class="n">payload_in</span><span class="p">,</span> <span class="n">tag_in</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// after this call the messages are invalidated</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="p">...</span> <span class="c1">// remainder of the program, see below</span>
</pre></div>
</div>
<p>Resulting in the output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$00: payload: 1000, tag: 1
$03: payload: 1003, tag: 1
$02: payload: 1002, tag: 1
$13: payload: 1013, tag: 1
...
</pre></div>
</div>
<p>A similar method can be used to send data up (from the Epiphany cores to the host). If you have followed along with our discussion so far the second half of the kernel code should be self explanatory:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: ecore_code.c</span>
<span class="p">...</span> <span class="c1">// obtain initial data, see above</span>

<span class="kt">int</span> <span class="n">payload</span> <span class="o">=</span> <span class="n">payload_in</span> <span class="o">+</span> <span class="mi">1000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="n">ebsp_send_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="n">bsp_end</span><span class="p">();</span>
</pre></div>
</div>
<p>Note that now we are using our processor number as the tag, such that the host can use the tag to differentiate between messages coming from different cores. Usage of <code class="docutils literal notranslate"><span class="pre">ebsp_send_up</span></code> is limited to the final superstep, i.e. between the last call to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> and the call to <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code>. In the host program we can read the resulting messages similarly to how we read them on the Epiphany processor:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: host_code.c</span>

<span class="p">...</span>
<span class="n">ebsp_spmd</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">packets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">accum_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">ebsp_qsize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">packets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">accum_bytes</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">payload_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tag_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packets</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ebsp_get_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tag_in</span><span class="p">);</span>
    <span class="n">ebsp_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">payload_in</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;payload: %i, tag: %i&quot;</span><span class="p">,</span> <span class="n">payload_in</span><span class="p">,</span> <span class="n">tag_in</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ebsp_end</span><span class="p">();</span>
</pre></div>
</div>
<p>This gives the output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>payload: 2001, tag: 1
payload: 2013, tag: 13
payload: 2003, tag: 3
payload: 2002, tag: 2
...
</pre></div>
</div>
<p>For the first time we have written data to the cores, applied a transformation to the data using the Epiphany cores, and sent it back up to the host program.</p>
<p>Message passing is a nice way to get initial data to the Epiphany cores, and to get the results of computations back to the host. However, it is very restrictive, and does not give the user a lot of control over the way the data gets sent down. An alternative approach is given by <code class="docutils literal notranslate"><span class="pre">ebsp_write</span></code> and <code class="docutils literal notranslate"><span class="pre">ebsp_read</span></code>. These calls require manually addressing the local memory on each core. Every core has 32kb of local memory, corresponding to addresses <code class="docutils literal notranslate"><span class="pre">0x0000</span></code> to <code class="docutils literal notranslate"><span class="pre">0x8000</span></code>. The default settings of EBSP put the program data at the start of this space (i.e. at <code class="docutils literal notranslate"><span class="pre">0x0000</span></code>), and the stack moves downwards from the end (i.e. at <code class="docutils literal notranslate"><span class="pre">0x8000</span></code>). Using <code class="docutils literal notranslate"><span class="pre">ebsp_write</span></code> from the host program, you can prepare data at specific spaces on the local cores:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ebsp_write</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mh">0x5000</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This would write 4 integers to each core starting at <code class="docutils literal notranslate"><span class="pre">0x5000</span></code>. Similarly, <code class="docutils literal notranslate"><span class="pre">ebsp_read</span></code> can be used to retrieve data from the cores. We would not recommend this approach for users just beginning with the Parallella and EBSP in particular. A better approach to move large amounts of data from and to the Epiphany processor uses <em>data streams</em>, which will be introduced in the next EBSP release. This allows data to be moved in predetermined <em>chunks</em>, which are acted upon independently. We will explain this approach in detail in a future blogpost.</p>
</div>
<div class="section" id="interface-vertical-communication">
<h4>Interface (Vertical communication)<a class="headerlink" href="#interface-vertical-communication" title="Permalink to this headline">¶</a></h4>
<div class="section" id="host">
<h5>Host<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310ebsp_qsizePiPi">
<span id="_CPPv210ebsp_qsizePiPi"></span><span id="ebsp_qsize__iP.iP"></span><span class="target" id="host__bsp_8h_1a0dc8a00e88a2ecb254bde2ec8665159e"></span>void <code class="descname">ebsp_qsize</code><span class="sig-paren">(</span>int *<em>packets</em>, int *<em>accum_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the amount of messages in the queue and their total size in bytes. </p>
<p><p>Use only for gathering result messages at the end of a BSP program. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">packets</span></code>: A pointer to an integer receiving the number of messages </li>
<li><code class="docutils literal notranslate"><span class="pre">accum_bytes</span></code>: The total size of the data payloads of the messages, in bytes.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv316ebsp_set_tagsizePi">
<span id="_CPPv216ebsp_set_tagsizePi"></span><span id="ebsp_set_tagsize__iP"></span><span class="target" id="host__bsp_8h_1a27bb2cce1a92dbf95ab28ea662216370"></span>void <code class="descname">ebsp_set_tagsize</code><span class="sig-paren">(</span>int *<em>tag_bytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set initial tagsize for message passing. </p>
<p><p>The default tagsize is zero. This function should be called at most once, before any messages are sent. Calling this when receiving messages results in undefined behaviour.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_bytes</span></code>: A pointer to an integer containing the new tagsize, receiving the old tagsize on return.</li>
</ul>
</dd>
</dl>
</p>
<p>It is not possible to send messages with different tag sizes. Doing so will result in undefined behaviour.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The tagsize set using this function is also used for inter-core messages. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv316ebsp_get_tagsizev">
<span id="_CPPv216ebsp_get_tagsizev"></span><span id="ebsp_get_tagsize"></span><span class="target" id="host__bsp_8h_1a47cf6f4bc4ee48eddc146f52d7eb8f95"></span>int <code class="descname">ebsp_get_tagsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Get the tagsize as set by the Epiphany program. </p>
<p><p>Use only for gathering result messages at the end of a BSP program.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The tagsize in bytes</dd>
</dl>
</p>
<p>When <a class="reference internal" href="index.html#host__bsp_8h_1a12385c882b6096484952fe7acad958bd"><span class="std std-ref">ebsp_spmd()</span></a> returns, the Epiphany program can have set a different tagsize which can be obtained using this function. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv314ebsp_send_downiPKvPKvi">
<span id="_CPPv214ebsp_send_downiPKvPKvi"></span><span id="ebsp_send_down__i.voidCP.voidCP.i"></span><span class="target" id="host__bsp_8h_1ae51209685120c4965c41b2056fee1872"></span>void <code class="descname">ebsp_send_down</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>tag</em>, <em class="property">const</em> void *<em>payload</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Send a message to the Epiphany cores. </p>
<p><p>This is the preferred way to send initial data (for computation) to the Epiphany cores.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to the message tag </li>
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the payload in bytes</li>
</ul>
</dd>
</dl>
</p>
<p>The size of the buffer pointed to by tag has to be <code class="docutils literal notranslate"><span class="pre">tagsize</span></code>, and must be the same for every message being sent. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv310ebsp_writeiPv5off_ti">
<span id="_CPPv210ebsp_writeiPv5off_ti"></span><span id="ebsp_write__i.voidP.off_t.i"></span><span class="target" id="host__bsp_8h_1a00f9d9253d6ffa496ee041955689c99a"></span>int <code class="descname">ebsp_write</code><span class="sig-paren">(</span>int <em>pid</em>, void *<em>src</em>, off_t <em>dst</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write data to the Epiphany processor. </p>
<p><p>This is an alternative to the BSP Message Passing system. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to the source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination address (as seen by the Epiphany core) </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: The amount of bytes to be copied </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39ebsp_readi5off_tPvi">
<span id="_CPPv29ebsp_readi5off_tPvi"></span><span id="ebsp_read__i.off_t.voidP.i"></span><span class="target" id="host__bsp_8h_1a65423fcb58e7d782c3914a8689dc527f"></span>int <code class="descname">ebsp_read</code><span class="sig-paren">(</span>int <em>pid</em>, off_t <em>src</em>, void *<em>dst</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read data from the Epiphany processor. </p>
<p><p>This is an alternative to the BSP Message Passing system. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the source processor </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source address (as seen by the Epiphany core) </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a buffer receiving the data </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: The amount of bytes to be copied </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv312ebsp_send_upPKvPKvi">
<span id="_CPPv212ebsp_send_upPKvPKvi"></span><span id="ebsp_send_up__voidCP.voidCP.i"></span><span class="target" id="e__bsp_8h_1a123ebda609339b79f9a05b1e5dd856b8"></span>void <code class="descname">ebsp_send_up</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>tag</em>, <em class="property">const</em> void *<em>payload</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv312ebsp_send_upPKvPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a message to the host processor after the computation is finished. </p>
<p><p>This will send a message back to the host after a computation. It is used to tranfer any results.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to the tag data </li>
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to the data </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the data</li>
</ul>
</dd>
</dl>
</p>
<p>When this function returns, the data has been copied so the user can use the buffer for other purposes.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd><ul class="simple">
<li><a class="reference internal" href="index.html#e__bsp_8h_1a123ebda609339b79f9a05b1e5dd856b8"><span class="std std-ref">ebsp_send_up()</span></a> should an only be used between the last call to <a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a> and <a class="reference internal" href="index.html#e__bsp_8h_1ad794334e180b711537499871020a76fe"><span class="std std-ref">bsp_end()</span></a></li>
<li><a class="reference internal" href="index.html#e__bsp_8h_1a123ebda609339b79f9a05b1e5dd856b8"><span class="std std-ref">ebsp_send_up()</span></a> should only be used when no <a class="reference internal" href="index.html#e__bsp_8h_1a2d79a679686a5357acc6ba936ec60017"><span class="std std-ref">bsp_send()</span></a> messages have been passed after the last <a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a></li>
<li>after calling <a class="reference internal" href="index.html#e__bsp_8h_1a123ebda609339b79f9a05b1e5dd856b8"><span class="std std-ref">ebsp_send_up()</span></a> at least once, a call to any other queue functions or to <a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a> will lead to undefined behaviour </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
<span id="document-streaming"></span><div class="section" id="data-streams">
<h3>Data streams<a class="headerlink" href="#data-streams" title="Permalink to this headline">¶</a></h3>
<div class="section" id="streaming">
<h4>Streaming<a class="headerlink" href="#streaming" title="Permalink to this headline">¶</a></h4>
<p>When dealing with problems that involve a lot of data such as images or large matrices, it is often the case that the data for the problem does not fit on the combined local memory of the Epiphany processor. In order to work with the data we must then use the larger (but much slower) external memory, which slows the programs down tremendously.</p>
<p>For these situations we provide a <em>streaming</em> mechanism. When writing your program to use streams, it will work on smaller tokens of the problem at any given time – such that the data currently being treated is always local to the core. The EBSP library prepares the next token to work on while the previous token is being processed such that there is minimal downtime because the Epiphany cores are waiting for the slow external memory.</p>
<div class="section" id="making-and-using-down-streams">
<h5>Making and using down streams<a class="headerlink" href="#making-and-using-down-streams" title="Permalink to this headline">¶</a></h5>
<p>A stream contains data to be processed by an Epiphany core, and can also be used to obtain results from computations performed by the Epiphany core. Every stream has a <em>total size</em> and a <em>token size</em>. The total size is the total number of bytes of the entire set of data. This set of data then gets partitioned into tokens consisting of the number of bytes set by the token size. This size need not be constant (i.e. it may vary over a single stream), but for our discussion here we will assume that it is constant.</p>
<p>A stream is created before the call to <code class="docutils literal notranslate"><span class="pre">ebsp_spmd</span></code> on the host processor. The host prepares the data to be processed by the Epiphany cores, and the EBSP library then performs the necessary work needed for each core to receives its token. Note that this data is copied efficiently to the external memory upon creation of the stream, so that the user data should be stored in the ordinary RAM, e.g. allocated by a call to <code class="docutils literal notranslate"><span class="pre">malloc</span></code>. A stream is created as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// (on the host)</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count_in_token</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="c1">// ... fill data</span>
<span class="n">bsp_stream_create</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">count_in_token</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>This will create a stream containing user data. This stream is chopped up in <code class="docutils literal notranslate"><span class="pre">256/32</span> <span class="pre">=</span> <span class="pre">8</span></code> tokens. If you want to use this streams in the kernel of a core you need to <em>open</em> it and <em>move tokens</em> from a stream to the local memory. Every stream you create on the host gets is identified by the order in which they are created, starting from index <code class="docutils literal notranslate"><span class="pre">0</span></code>. For example, the stream we created above will obtain the id <code class="docutils literal notranslate"><span class="pre">0</span></code>. A second stream (regardless of whether it is up or down) will be identified with <code class="docutils literal notranslate"><span class="pre">1</span></code>, etc. <em>These identifiers are shared between cores</em>. Opening a stream is done by using this identifier, for example, to open a stream with identifier <code class="docutils literal notranslate"><span class="pre">3</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bsp_stream</span> <span class="n">mystream</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">bsp_stream_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mystream</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After this call, the stream will start copying data to the core, but the data is not necessarily there yet (it might still be copying). A stream can only be opened by <em>a single core at a time</em>. To access this data we <em>move</em> a token:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get some data</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">bsp_stream_move_down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mystream</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// The data is now in buffer</span>
</pre></div>
</div>
<p>The first argument is the stream object that was filled using <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>. The second argument is a pointer to a pointer that will be set to the data location. The final <code class="docutils literal notranslate"><span class="pre">double_buffer</span></code> argument, gives you the option to start writing the next token to local memory (using the DMA engine), while you process the current token that you just moved down. This can be done simultaneously to your computations, but will take up twice as much memory. It depends on the specific situation whether double buffered mode should be turned on or off. Subsequent blocks are obtained using repeated calls to <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code>.</p>
<p>If you want to use a token multiple times at different stages of your algorithm, you need to be able to instruct EBSP to change which token you want to obtain. Internally the EBSP system has a <em>cursor</em> for each stream which points to the next token that should be obtained. You can modify this cursor using the following two functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// move the cursor of the stream forward by 5 tokens</span>
<span class="n">bsp_stream_seek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mystream</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// move the cursor of the stream back by 3 tokens</span>
<span class="n">bsp_stream_seek</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mystream</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>When you exceed the bounds of the stream, it will be set to the final or first token respectively. Note that this gives you random access inside your streams. Therefore our streaming approach should actually be called <em>pseudo-streaming</em>, because formally streaming algorithms only process tokens in a stream a constant number of times. However on the Epiphany we can provide random-access in our streams, opening the door to different semantics such as moving the cursor.</p>
</div>
<div class="section" id="moving-results-back-up">
<h5>Moving results back up<a class="headerlink" href="#moving-results-back-up" title="Permalink to this headline">¶</a></h5>
<p>A stream can also be used to move results back up, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">buffer1</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">buffer2</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">curbuffer</span> <span class="o">=</span> <span class="n">buffer1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">otherbuffer</span> <span class="o">=</span> <span class="n">buffer2</span><span class="p">;</span>

<span class="n">ebsp_stream</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_stream_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// open stream 0</span>
<span class="k">while</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// Fill curbuffer</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">curbuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="c1">// Send up</span>
    <span class="n">bsp_stream_move_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">curbuffer</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Use other bufferfer</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">curbuffer</span><span class="p">,</span> <span class="n">otherbuffer</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buffer1</span><span class="p">);</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buffer2</span><span class="p">);</span>
</pre></div>
</div>
<p>Here, we have two buffers containing data. While filling one of the buffers with data, we move the other buffer up. We do this using the <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_up</span></code> function which has as arguments respectively: the stream handle, the data to send up, the size of the data to send up, and a flag that indicates whether we want to <em>wait for completion</em>. In this case, we do not wait, but use two buffers to perform computations and to send data up to the host simulatenously.</p>
</div>
<div class="section" id="closing-streams">
<h5>Closing streams<a class="headerlink" href="#closing-streams" title="Permalink to this headline">¶</a></h5>
<p>The EBSP stream system allocates buffers for you on the cores. When you are done with a stream you should tell the EBSP system by calling:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">bsp_stream_close</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_stream</span><span class="p">);</span>
</pre></div>
</div>
<p>which will free the buffers for other use, and allow other cores to use the streams.</p>
</div>
</div>
<div class="section" id="interface">
<h4>Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h4>
<div class="section" id="host">
<h5>Host<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv317bsp_stream_createiiPKv">
<span id="_CPPv217bsp_stream_createiiPKv"></span><span id="bsp_stream_create__i.i.voidCP"></span><span class="target" id="host__bsp_8h_1ae7db595dbbbfde687bc1a208e419a7d8"></span>void *<code class="descname">bsp_stream_create</code><span class="sig-paren">(</span>int <em>stream_size</em>, int <em>token_size</em>, <em class="property">const</em> void *<em>initial_data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Creates a generic stream for streaming data to or from an Epiphany core. </p>
<p><p>The function returns NULL on failure.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to a section of external memory storing the tokens.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream_size</span></code>: The total number of bytes of data in the stream. </li>
<li><code class="docutils literal notranslate"><span class="pre">token_size</span></code>: The size in bytes of a single token. Must be at least 16. </li>
<li><code class="docutils literal notranslate"><span class="pre">initial_data</span></code>: (Optional) The data which should be streamed to an Epiphany core. </li>
</ul>
</dd>
</dl>
</p>
<p>If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is nonzero, it is copied to the stream (<code class="docutils literal notranslate"><span class="pre">stream_size</span></code> bytes). If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is zero, an empty stream of size <code class="docutils literal notranslate"><span class="pre">stream_size</span></code> is created. In this case, <code class="docutils literal notranslate"><span class="pre">stream_size</span></code> should be the maximum number of bytes that will be sent up from the Epiphany cores to the host.</p>
<p>This function prints an error if <code class="docutils literal notranslate"><span class="pre">token_size</span></code> is less than 16.</p>
<p>The format of the data pointed to by the return value is as follows: Before every token, there are two integers that specify the size of the preceding token and the size of the token itself.</p>
<p>00000000, nextsize, data, prevsize, nextsize, data, … prevsize, nextsize, data, prevsize, 00000000</p>
<p>So a header consists of two integers (8 byte total). The two sizes do NOT include these headers. They are only the size of the data inbetween.</p>
<p>If you want to use the returned pointer directly you have to manually take care of this data format.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is nonzero, the data is copied so that after the call it can safely be freed or overwritten by the user. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv315bsp_stream_openP11ebsp_streami">
<span id="_CPPv215bsp_stream_openP11ebsp_streami"></span><span id="bsp_stream_open__ebsp_streamP.i"></span><span class="target" id="e__bsp_8h_1a4afd821ffa428a5c21e4db004e2d2f2f"></span>int <code class="descname">bsp_stream_open</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, int <em>stream_id</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Open a stream that was created using <code class="docutils literal notranslate"><span class="pre">bsp_stream_create</span></code> on the host. </p>
<p><p>The first stream created by the host will have </p>
<code class="docutils literal notranslate"><span class="pre">stream_id</span></code> 0.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Nonzero if succesful.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: Pointer to an existing <code class="docutils literal notranslate"><span class="pre">bsp_stream</span></code> struct to hold the stream data. This struct can be allocated on the stack by the user. </li>
<li><code class="docutils literal notranslate"><span class="pre">stream_id</span></code>: The index of the stream. </li>
</ul>
</dd>
</dl>
</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span>bsp_stream mystream;
if( bsp_stream_open(&amp;mystream, 3) ) {
    // Get some data
    void* buffer = 0;
    bsp_stream_move_down(&amp;mystream, &amp;buffer, 0);
    // The data is now in buffer
    // Finally, close the stream
    bsp_stream_close(&amp;mystream);`
}
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function has to be called <em>before</em> performing any other operation on the stream. </dd>
<dt><strong>Remark</strong></dt>
<dd>A call to the function should always match a single call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_close</span></code>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv316bsp_stream_closeP11ebsp_stream">
<span id="_CPPv216bsp_stream_closeP11ebsp_stream"></span><span id="bsp_stream_close__ebsp_streamP"></span><span class="target" id="e__bsp_8h_1acab67dc209d2b6fba1650292b97f73ff"></span>void <code class="descname">bsp_stream_close</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Wait for pending transfers to complete and close a stream. </p>
<p><p>Behaviour is undefined if </p>
<code class="docutils literal notranslate"><span class="pre">stream</span></code> is not a handle opened by <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream, opened by <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>.</li>
</ul>
</dd>
</dl>
</p>
<p>Cleans up the stream, and frees any buffers that may have been used by the stream. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv318bsp_stream_move_upP11ebsp_streamPKvii">
<span id="_CPPv218bsp_stream_move_upP11ebsp_streamPKvii"></span><span id="bsp_stream_move_up__ebsp_streamP.voidCP.i.i"></span><span class="target" id="e__bsp_8h_1a4678a61cc1a9eae55c55d890046410ce"></span>int <code class="descname">bsp_stream_move_up</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, <em class="property">const</em> void *<em>data</em>, int <em>data_size</em>, int <em>wait_for_completion</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Write a local token up to a stream. </p>
<p><p>The function </p>
<em>always</em> waits for the previous token to have finished.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes written. Zero if an error has occurred.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data to be sent up the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">data_size</span></code>: The size of the data to be sent, i.e. the size of the token. Behaviour is undefined if it is not a multiple of 8. If it is not a multiple of 8 bytes then transfers will be slow. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code>: If nonzero this function blocks untill the data is completely written to the stream. </li>
</ul>
</dd>
</dl>
</p>
<p>If <code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code> is nonzero, this function will wait untill the data is transferred. This corresponds to single buffering.</p>
<p>Alternativly, double buffering can be used as follows. Set <code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code> to zero and continue constructing the next token in a different buffer. Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">buf1</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">buf2</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">curbuf</span> <span class="o">=</span> <span class="n">buf1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">otherbuf</span> <span class="o">=</span> <span class="n">buf2</span><span class="p">;</span>

<span class="n">ebsp_stream</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_stream_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// open stream 0</span>
<span class="k">while</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// Fill curbuf</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">curbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    
    <span class="c1">// Send up</span>
    <span class="n">bsp_stream_move_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Use other buffer</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">curbuf</span><span class="p">,</span> <span class="n">otherbuf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Behaviour is undefined if the stream was not opened using <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>. </dd>
<dt><strong>Remark</strong></dt>
<dd>Memory is transferred using the <code class="docutils literal notranslate"><span class="pre">DMA1</span></code> engine. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv320bsp_stream_move_downP11ebsp_streamPPvi">
<span id="_CPPv220bsp_stream_move_downP11ebsp_streamPPvi"></span><span id="bsp_stream_move_down__ebsp_streamP.voidPP.i"></span><span class="target" id="e__bsp_8h_1aa23b8ef4ae753261dea1a7c17c8734d1"></span>int <code class="descname">bsp_stream_move_down</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, void **<em>buffer</em>, int <em>preload</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the next token from a stream. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes of the obtained chunk. If stream has finished or an error has occurred this function will return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</dd>
<dt><strong>Remark</strong></dt>
<dd>Behaviour is undefined if the stream was not opened using <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>. </dd>
<dt><strong>Remark</strong></dt>
<dd>Memory is transferred using the <code class="docutils literal notranslate"><span class="pre">DMA1</span></code> engine. </dd>
<dt><strong>Remark</strong></dt>
<dd>When using double buffering, the BSP system will allocate memory for the next chunk, and will start writing to it using the DMA engine while the current chunk is processed. This requires more (local) memory, but can greatly increase the overall speed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Receives a pointer to a local copy of the next token. </li>
<li><code class="docutils literal notranslate"><span class="pre">preload</span></code>: If this parameter is nonzero then the BSP system will preload the next token asynchroneously (double buffering). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv315bsp_stream_seekP11ebsp_streami">
<span id="_CPPv215bsp_stream_seekP11ebsp_streami"></span><span id="bsp_stream_seek__ebsp_streamP.i"></span><span class="target" id="e__bsp_8h_1aac6a2e9041be25b8903b6bb7c564186e"></span>void <code class="descname">bsp_stream_seek</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, int <em>delta_tokens</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Move the cursor in the stream, to change the next token to be obtained. </p>
<p><p>If </p>
<code class="docutils literal notranslate"><span class="pre">delta_tokens</span></code> is out of bounds, then the cursor will be moved to the start or end of the stream respectively. <code class="docutils literal notranslate"><span class="pre">bsp_stream_seek(i,</span> <span class="pre">INT_MIN)</span></code> will set the cursor to the start <code class="docutils literal notranslate"><span class="pre">bsp_stream_seek(i,</span> <span class="pre">INT_MAX)</span></code> will set the cursor to the end of the stream<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">delta_tokens</span></code>: The number of tokens to skip if <code class="docutils literal notranslate"><span class="pre">delta_tokens</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, or to go back if <code class="docutils literal notranslate"><span class="pre">delta_tokens</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>.</li>
</ul>
</dd>
</dl>
</p>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> is used with <code class="docutils literal notranslate"><span class="pre">preload</span></code> enabled (meaning the last call to that function had <code class="docutils literal notranslate"><span class="pre">preload</span></code> enabled), then the preloaded token will not be changed, so the first call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> after this will still yield a token from the previous position. If <code class="docutils literal notranslate"><span class="pre">preload</span></code> was not enabled then the next call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> will yield a token from the new position.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function provides a mechanism through which chunks can be obtained multiple times. It gives you random access in the memory in the data stream. </dd>
<dt><strong>Remark</strong></dt>
<dd>This function has <code class="docutils literal notranslate"><span class="pre">O(delta_tokens)</span></code> complexity. </dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
<span id="document-other_features"></span><div class="section" id="other-features">
<h3>Other features<a class="headerlink" href="#other-features" title="Permalink to this headline">¶</a></h3>
<p>There are two features we did not yet discuss. The first is timers, which are useful for getting information on the running time of your programs. The second is intervening in programs that are currently running on the Epiphany using the host.</p>
<div class="section" id="timers">
<h4>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h4>
<p>We provide two mechanisms for getting running time information. The first uses the first timer (of the two) on the Epiphany core and is accurate for relatively short time intervals (less than about 7 seconds). It is used in the following manner:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span> <span class="n">t_start</span> <span class="o">=</span> <span class="n">bsp_time</span><span class="p">();</span>
<span class="c1">// ... perform computation</span>
<span class="kt">float</span> <span class="n">t_end</span> <span class="o">=</span> <span class="n">bsp_time</span><span class="p">();</span>
<span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">;</span>
</pre></div>
</div>
<p>The variable result than holds the time taken for the computation in seconds. If you want access to the number of clockcycles used for the computation we provide a similar function <a class="reference internal" href="#ebsp-raw-time"><span class="std std-ref">ebsp_raw_time()</span></a> which gives the number of clockcycles as an unsigned integer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_start</span> <span class="o">=</span> <span class="n">bsp_raw_time</span><span class="p">();</span>
<span class="c1">// ... perform computation</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">t_end</span> <span class="o">=</span> <span class="n">bsp_raw_time</span><span class="p">();</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the default Epiphany clockfrequency is about 600 MHz, such that 600000000 cycles is equal to one second.</p>
<p>Note that there are two separate timers available on the Epiphany cores, identified by <code class="docutils literal notranslate"><span class="pre">E_CTIMER_0</span></code> and <code class="docutils literal notranslate"><span class="pre">E_CTIMER_1</span></code>. The Epiphany BSP library will only use <code class="docutils literal notranslate"><span class="pre">E_CTIMRE_0</span></code> so you are free to use the other timer in any way you require, using the Epiphany SDK.</p>
<p>The second method uses the system clock of the host to obtain the elapsed time. Because of varying amounts of latency this can be very inaccurate (its precision is in the order of milliseconds), but supports time intervals of arbitrary length. This timer can be used by calling the function <code class="docutils literal notranslate"><span class="pre">ebsp_host_time()</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span> <span class="n">t_start</span> <span class="o">=</span> <span class="n">ebsp_host_time</span><span class="p">();</span>
<span class="c1">// ... perform (long) computation</span>
<span class="kt">float</span> <span class="n">t_end</span> <span class="o">=</span> <span class="n">ebsp_host_time</span><span class="p">();</span>
<span class="kt">float</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="interrupts">
<h4>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">¶</a></h4>
<p>It is possible to set up interrupt handlers using the Epiphany SDK functionality. The only interrupt that is explicitely and necessarily handled by the EBSP library is <code class="docutils literal notranslate"><span class="pre">E_DMA1_INT</span></code>. For more information on the using the DMA engine, see the section on memory management. There is a timer interrupt that can be used if needed. The Epiphany BSP library uses neither of the two timre interrupts. The maximum number of cycles that can be counted using the raw timer is <code class="docutils literal notranslate"><span class="pre">UINT_MAX</span></code> which is roughly 7 seconds on the 600 MHz cores. After reaching this maximum value, an interrupt will be fired.</p>
</div>
<div class="section" id="callbacks">
<h4>Callbacks<a class="headerlink" href="#callbacks" title="Permalink to this headline">¶</a></h4>
<p>If you want to use the host processor together with the Epiphany processor, you require some sort of syncing mechanism. In particular you might want to react to data that has been sent to external memory, or use the ARM in a map-reduce kind of setting. For this we provide a callback mechanism using <code class="docutils literal notranslate"><span class="pre">ebsp_set_sync_callback</span></code>. You can provide a function pointer, and this function will get called each time a core calls <code class="docutils literal notranslate"><span class="pre">ebsp_host_sync</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// on the host</span>
<span class="kt">void</span> <span class="nf">callback</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;ebsp_host_sync called on the Epiphany&quot;</span><span class="p">);</span>
    <span class="c1">// communicate with cores or react to data</span>
<span class="p">}</span>

<span class="p">..</span>
<span class="n">bsp_begin</span><span class="p">(</span><span class="n">bsp_nprocs</span><span class="p">());</span>
<span class="n">ebsp_set_sync_callback</span><span class="p">(</span><span class="n">callback</span><span class="p">);</span>
<span class="p">..</span>
</pre></div>
</div>
<p>Similarly we provide a callback mechanism for <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code>, which can be useful when developing your own library on top of EBSP.</p>
</div>
<div class="section" id="interface-timer-and-callback">
<h4>Interface (Timer and callback)<a class="headerlink" href="#interface-timer-and-callback" title="Permalink to this headline">¶</a></h4>
<div class="section" id="host">
<h5>Host<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv322ebsp_set_sync_callbackPFvvE">
<span id="_CPPv222ebsp_set_sync_callbackPFvvE"></span><span class="target" id="host__bsp_8h_1ad542fb7eba809cad18949b672708545b"></span>void <code class="descname">ebsp_set_sync_callback</code><span class="sig-paren">(</span>void (*<em>cb</em>)<span class="sig-paren">(</span><span class="sig-paren">)</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the (optional) callback for synchronizing epiphany cores with the host program. </p>
<p><p>This callback is called when all Epiphany cores have called ebsp_host_sync(). Note that this does not happen at bsp_sync(). </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cb</span></code>: A function pointer to the callback function</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv321ebsp_set_end_callbackPFvvE">
<span id="_CPPv221ebsp_set_end_callbackPFvvE"></span><span class="target" id="host__bsp_8h_1a96ce8db901942447741ee8d2ace5d161"></span>void <code class="descname">ebsp_set_end_callback</code><span class="sig-paren">(</span>void (*<em>cb</em>)<span class="sig-paren">(</span><span class="sig-paren">)</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the (optional) callback for finalizing. </p>
<p><p>This callback is called when </p>
<a class="reference internal" href="index.html#host__bsp_8h_1a12385c882b6096484952fe7acad958bd"><span class="std std-ref">ebsp_spmd()</span></a> finishes. It is primarily used by the ebsp memory inspector and should not be needed. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cb</span></code>: A function pointer to the callback function</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="epiphany">
<h5>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_timev">
<span id="_CPPv28bsp_timev"></span><span id="bsp_time"></span><span class="target" id="e__bsp_8h_1a6ee4e522d55605dc51db6ea33c06c3c2"></span>float <code class="descname">bsp_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the time in seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a> was called. </p>
<p><p>The native Epiphany timer does not support time differences longer than </p>
<code class="docutils literal notranslate"><span class="pre">UINT_MAX/(600000000)</span></code> which is roughly 7 seconds.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A floating point value with the number of elapsed seconds since the call to <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a></dd>
</dl>
</p>
<p>If you want to measure longer time intervals, we suggest you use the (less accurate) <a class="reference internal" href="index.html#e__bsp_8h_1aeb45a09e9b589b1fdc7ede2f84d612db"><span class="std std-ref">ebsp_host_time()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Using this in combination with <a class="reference internal" href="index.html#e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"><span class="std std-ref">ebsp_raw_time()</span></a> leads to unspecified behaviour, you should only use one of these in your program.</dd>
<dt><strong>Remark</strong></dt>
<dd>This uses the internal Epiphany <code class="docutils literal notranslate"><span class="pre">E_CTIMER_0</span></code> timer so the second timer can be used for other purposes. </dd>
</dl>
</p>
</dd></dl>

<span class="target" id="ebsp-raw-time"></span><dl class="function">
<dt id="_CPPv313ebsp_raw_timev">
<span id="_CPPv213ebsp_raw_timev"></span><span id="ebsp_raw_time"></span><span class="target" id="e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"></span>unsigned int <code class="descname">ebsp_raw_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the number of clockcycles that have passed since the previous call to <a class="reference internal" href="index.html#e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"><span class="std std-ref">ebsp_raw_time()</span></a>. </p>
<p><p>This function has less overhead than bsp_time.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An unsigned integer with the number of clockcycles</dd>
</dl>
</p>
<p>Divide the number of clockcycles by 600 000 000 to get the time in seconds.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Using this in combination with <a class="reference internal" href="index.html#e__bsp_8h_1a6ee4e522d55605dc51db6ea33c06c3c2"><span class="std std-ref">bsp_time()</span></a> leads to unspecified behaviour, you should only use one of these in your program.</dd>
<dt><strong>Remark</strong></dt>
<dd>This uses the internal Epiphany <code class="docutils literal notranslate"><span class="pre">E_CTIMER_0</span></code> timer so the second timer can be used for other purposes. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv314ebsp_host_timev">
<span id="_CPPv214ebsp_host_timev"></span><span id="ebsp_host_time"></span><span class="target" id="e__bsp_8h_1aeb45a09e9b589b1fdc7ede2f84d612db"></span>float <code class="descname">ebsp_host_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the time in seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a> was called. </p>
<p><p>This function uses the system clock of the host to obtain the elapsed time. Because of varying amounts of latency this can be very inaccurate (its precision is in the order of milliseconds), but it supports time intervals of arbitrary length. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A floating point value with the number of seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a></dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-output"></span><div class="section" id="output">
<h3>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h3>
<p>Using <code class="docutils literal notranslate"><span class="pre">printf</span></code> on the Epiphany you can send messages to a debugger. However, it can be very convenient to write directly to <code class="docutils literal notranslate"><span class="pre">stdout</span></code> using the Epiphany cores. For this we provide a mechanism to output information from each individual Epiphany core to the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> of the host program. For this you simply call <code class="docutils literal notranslate"><span class="pre">ebsp_message</span></code> completely identically to how you would call <code class="docutils literal notranslate"><span class="pre">printf</span></code> in regular programs.</p>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>Writing text:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">);</span> <span class="c1">// -&gt; $pid: Hello world!</span>
</pre></div>
</div>
<p>You can also output information for local variables using standard formatting strings:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;Hello world from core %i of %i!&quot;</span><span class="p">,</span>
             <span class="n">bsp_pid</span><span class="p">(),</span> <span class="n">bsp_nprocs</span><span class="p">());</span> <span class="c1">// -&gt; $pid: Hello world from core pid of 16!</span>
</pre></div>
</div>
<p>We would not recommend outputting floating point numbers through this method, because this pulls in a lot of floating-point conversion code which takes up precious memory and might even corrupt critical memory areas used by EBSP. In a future version we will provide a lightweight floating-point conversion implementation directly in our <code class="docutils literal notranslate"><span class="pre">ebsp_message</span></code> implementation.</p>
</div>
<div class="section" id="interface">
<h4>Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv312ebsp_messagePKcz">
<span id="_CPPv212ebsp_messagePKcz"></span><span id="ebsp_message__cCP.z"></span><span class="target" id="e__bsp_8h_1ad3a2c88749e9dab3e73b9923a5b86add"></span>void <code class="descname">ebsp_message</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>format</em>, ...<span class="sig-paren">)</span><br /></dt>
<dd><p>Output a debug message printf style. </p>
<p><a class="reference internal" href="index.html#e__bsp_8h_1ad3a2c88749e9dab3e73b9923a5b86add"><span class="std std-ref">ebsp_message()</span></a> outputs a debug message by sending it to shared memory So that the host processor can output it to the terminal The attributes in this definition make sure that the compiler checks the arguments for errors. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">format</span></code>: The formatting string in printf style</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<span id="document-memory_management"></span><div class="section" id="memory-management">
<h3>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
<p>Memory management on the Epiphany platform requires some special care so we discuss it in this separate section. The Epiphany cores have very little local (fast) memory, and access the external (larger) memory space is very slow. Therefore one needs to pay special attention to memory management in order to write good programs for the Epiphany platform.</p>
<p>We provide some functions that aid in memory allocation. These are not part of the offical BSP standard, but meant as a utility library. This page will cover these helper functions. If you are interested in the more technical details (specific for the Parallella), see <a class="reference internal" href="index.html#memory-details"><span class="std std-ref">Parallella memory details</span></a>.</p>
<div class="section" id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h4>
<p>In short, there are two types of memory:</p>
<ul class="simple">
<li>local memory: 32 KB for each core, fast</li>
<li>external memory: 32 MB shared for all cores, slow</li>
</ul>
<p>In principle, all computations should be performed on data in the fast local memory. However 32 KB might not be enough for all your data. In this case you have to store the data in external memory and transfer the required parts to local memory to do the computations. Access to external memory can be a factor 100 slower in some cases so this should be avoided when possible.</p>
<p>How do you know in what type of memory your data is stored? Let us look at the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">global_var</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">my_function</span><span class="p">(</span><span class="kt">int</span> <span class="n">argument</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">local_var</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">buffer1</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">buffer2</span> <span class="o">=</span> <span class="n">ebsp_ext_malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>


    <span class="c1">// ....</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buffer1</span><span class="p">)</span> <span class="n">ebsp_free</span><span class="p">(</span><span class="n">buffer1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">buffer2</span><span class="p">)</span> <span class="n">ebsp_free</span><span class="p">(</span><span class="n">buffer2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, the following variables will be stored in local memory:
- <code class="docutils literal notranslate"><span class="pre">global_var</span></code>
- <code class="docutils literal notranslate"><span class="pre">local_var</span></code>
- <code class="docutils literal notranslate"><span class="pre">argument</span></code>
- <code class="docutils literal notranslate"><span class="pre">buffer1</span></code>, as well as the data it points to
- <code class="docutils literal notranslate"><span class="pre">my_function</span></code> (the machine code)
However, <code class="docutils literal notranslate"><span class="pre">buffer2</span></code> points to data that is stored in the large <em>external memory</em>. The pointer itself is stored in local memory.</p>
<p>In general, global and local variables in your C source code will be stored in local memory, unless otherwise specified with some special gcc attributes. Code itself (i.e. the machine code) can also be stored in both types of memory. Normal C code will be stored in local memory, unless specified using gcc attributes. Variables allocated using <a class="reference internal" href="#_CPPv315ebsp_ext_mallocj" title="ebsp_ext_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_ext_malloc()</span></code></a> are stored in external memory.</p>
</div>
<div class="section" id="data-copying">
<h4>Data copying<a class="headerlink" href="#data-copying" title="Permalink to this headline">¶</a></h4>
<div class="section" id="direct-memcpy">
<h5>Direct memcpy<a class="headerlink" href="#direct-memcpy" title="Permalink to this headline">¶</a></h5>
<p>In C you can copy data using <code class="docutils literal notranslate"><span class="pre">memcpy(destination,</span> <span class="pre">source,</span> <span class="pre">nbytes)</span></code>. This function is available on the Epiphany as well, but its implementation (depending on the version of gcc and newlib) is not properly optimized for the Epiphany architecture. In particular the function itself is stored in external memory (unless you choose to save the complete C library in local memory) and it also does not perform 8-byte transfers. For this reason we have created <a class="reference internal" href="#_CPPv311ebsp_memcpyPvPKv6size_t" title="ebsp_memcpy"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_memcpy()</span></code></a> which is stored in local memory and does transfers utilizing 8-byte read/write instructions when possible. It is therefore faster than <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> and should be preferred.</p>
</div>
<div class="section" id="dma-engine">
<h5>DMA engine<a class="headerlink" href="#dma-engine" title="Permalink to this headline">¶</a></h5>
<p>Each Epiphany processor contains a so-called DMA engine which can be used to transfer data. This DMA engine can be viewed as a separate core that can copy data while the normal Epiphany core does other things. The Epiphany core can simply give the DMA engine a task (a source and destination address along with some other options) and the DMA engine will copy the data so that the Epiphany core can continue with other operations. The advantage of the DMA engine over normal memory access is that the DMA engine is <strong>faster</strong> and can transfer data <strong>while the CPU does other things</strong>. There are <strong>two DMA channels</strong>, meaning that two pairs of source/destination addresses can be set and the Epiphany core can continue while the DMA engine is transfering data.</p>
<p>We have provided some utility functions to make the use of the DMA engine easier.  If you want to use the DMA engine using the <code class="docutils literal notranslate"><span class="pre">e_dma_xxx</span></code> functions from the ESDK you can do so, but only use <code class="docutils literal notranslate"><span class="pre">E_DMA_0</span></code>. The other DMA channel (<code class="docutils literal notranslate"><span class="pre">E_DMA_1</span></code>) is used internally by the library.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The DMA engine can not transfer data from the local core to itself (i.e. to another memory location in the same core). Either the source or destination (or both) should point to another core’s memory or to external memory.</p>
</div>
<p>The Epiphany BSP library provides the functions <a class="reference internal" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a> and <a class="reference internal" href="#_CPPv313ebsp_dma_waitP15ebsp_dma_handle" title="ebsp_dma_wait"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_wait()</span></code></a>. They implement a queue of DMA tasks that are handled sequentially. With <a class="reference internal" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a> you can push a task to this queue and with <a class="reference internal" href="#_CPPv313ebsp_dma_waitP15ebsp_dma_handle" title="ebsp_dma_wait"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_wait()</span></code></a> you can wait for the task to complete:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// A handle identifies the transfer task</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor_1</span><span class="p">;</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor_2</span><span class="p">;</span>

<span class="c1">// Start two transfers</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_1</span><span class="p">,</span> <span class="n">destination_1</span><span class="p">,</span> <span class="n">source_1</span><span class="p">,</span> <span class="n">data_size_1</span><span class="p">);</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_2</span><span class="p">,</span> <span class="n">destination_2</span><span class="p">,</span> <span class="n">source_2</span><span class="p">,</span> <span class="n">data_size_2</span><span class="p">);</span>

<span class="c1">// perform some computations</span>
<span class="c1">// ...</span>

<span class="c1">// Wait for them to finish</span>
<span class="n">ebsp_dma_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_1</span><span class="p">);</span>
<span class="n">ebsp_dma_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_2</span><span class="p">);</span>
</pre></div>
</div>
<p>Pushing a new task will start the DMA engine if it was not started yet. If it was already running, the library will add the task to an internal queue and automatically point the DMA engine to the next task when it is finished. For those who are interested, this is implemented using interrupts.</p>
<p>In order to use the DMA engine to write data to another core, one needs a memory address that points to the local memory of another core. For this we provide the function <a class="reference internal" href="#_CPPv323ebsp_get_direct_addressiPKv" title="ebsp_get_direct_address"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_get_direct_address()</span></code></a>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Some buffer</span>
<span class="kt">float</span> <span class="n">data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="c1">// Register it in the BSP system</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="c1">// Get an address for the data buffer on the core with pid 3</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">remote_data</span> <span class="o">=</span> <span class="n">ebsp_get_direct_address</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming_data</span><span class="p">);</span>

<span class="c1">// Now we can pass &#39;remote_data&#39; to the DMA engine, or use it directly</span>
<span class="o">*</span><span class="n">remote_data</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>The above example shows how to obtain an address of a variable on another core. This address can then be passed as source or destination to <a class="reference internal" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a>.</p>
</div>
</div>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<div class="section" id="memory-allocation">
<h5>Memory allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h5>
<p>The memory allocation functions work analogously to the normal C function <code class="docutils literal notranslate"><span class="pre">malloc</span></code>. Memory allocated by <a class="reference internal" href="#_CPPv315ebsp_ext_mallocj" title="ebsp_ext_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_ext_malloc()</span></code></a> and by <a class="reference internal" href="#_CPPv311ebsp_mallocj" title="ebsp_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_malloc()</span></code></a> can both be freed with the same function <a class="reference internal" href="#_CPPv39ebsp_freePv" title="ebsp_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_free()</span></code></a>, as in the following example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate local memory</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">local_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;Memory allocation failed!&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">local_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
    <span class="c1">// Free the memory</span>
    <span class="n">ebsp_free</span><span class="p">(</span><span class="n">local_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Allocate external memory</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">external_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_ext_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">external_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">do_computation</span><span class="p">();</span>
    <span class="c1">// Free the memory</span>
    <span class="n">ebsp_free</span><span class="p">(</span><span class="n">external_data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that calling <a class="reference internal" href="#_CPPv39ebsp_freePv" title="ebsp_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_free()</span></code></a> with a null pointer results in undefined behaviour, so the following is <strong>NOT</strong> allowed:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="o">*</span> <span class="n">local_data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">local_data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">local_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// !!! WRONG: This will crash if local_data is NULL</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">local_data</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="external-memory-dma-transfers">
<h5>External memory DMA transfers<a class="headerlink" href="#external-memory-dma-transfers" title="Permalink to this headline">¶</a></h5>
<p>The following example demonstrates the use of <a class="reference internal" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a> to write a buffer of local data to external memory and read a buffer from external memory using the DMA engine.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate buffers</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">external_data_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_ext_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">external_data_2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_ext_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">local_data_1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">local_data_2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

<span class="c1">// Fill local buffer 1 with data</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">local_data_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>

<span class="c1">// Fill external buffer 2 with data</span>
<span class="c1">// Note that this is slow</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">external_data_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>

<span class="c1">// To &#39;tasks&#39; for the DMA engine:</span>
<span class="c1">// Copy local_data_1 to external_data_1 (write to external memory)</span>
<span class="c1">// Copy external_data_2 to local_data_2 (read from external memory)</span>

<span class="c1">// This corresponds to two handles</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor_1</span><span class="p">;</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor_2</span><span class="p">;</span>

<span class="c1">// Start the DMA with the writing task</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_1</span><span class="p">,</span> <span class="n">external_data_1</span><span class="p">,</span> <span class="n">local_data_1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">local_data_1</span><span class="p">));</span>

<span class="c1">// We can &#39;push&#39; the next task while the DMA already works on the first task</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_2</span><span class="p">,</span> <span class="n">local_data_2</span><span class="p">,</span> <span class="n">external_data_2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">local_data_2</span><span class="p">));</span>

<span class="c1">// Do lengthy computation in the mean time</span>
<span class="n">do_computations</span><span class="p">();</span>

<span class="c1">// Wait for the DMA to finish the second task</span>
<span class="n">ebsp_dma_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor_2</span><span class="p">);</span>

<span class="c1">// Because the DMA performs the tasks in order,</span>
<span class="c1">// we can be assured that the first task is completed as well</span>
</pre></div>
</div>
</div>
<div class="section" id="core-to-core-dma-transfers">
<h5>Core to core DMA transfers<a class="headerlink" href="#core-to-core-dma-transfers" title="Permalink to this headline">¶</a></h5>
<p>To use the DMA to transfer data to another core, we need to get the address that points to another core. This can be done using <a class="reference internal" href="#_CPPv323ebsp_get_direct_addressiPKv" title="ebsp_get_direct_address"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_get_direct_address()</span></code></a>. In the following example we have to arrays: <code class="docutils literal notranslate"><span class="pre">my_data</span></code> and <code class="docutils literal notranslate"><span class="pre">incoming_data</span></code>. The idea is to copy the contents of <code class="docutils literal notranslate"><span class="pre">my_data</span></code> on the local core into <code class="docutils literal notranslate"><span class="pre">incoming_data</span></code> on the next core. To do this, we first register <code class="docutils literal notranslate"><span class="pre">incoming_data</span></code>. After this we can get the address of the corresponding array on a remote core. In this case we take the core with pid <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">+</span> <span class="pre">1</span></code> where <code class="docutils literal notranslate"><span class="pre">s</span></code> is the pid of the local core. With this address we can now use <a class="reference internal" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a> to copy data using the DMA engine. During this transfer, other computations can be done. After this we use <a class="reference internal" href="#_CPPv313ebsp_dma_waitP15ebsp_dma_handle" title="ebsp_dma_wait"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_wait()</span></code></a> which blocks untill the transfer is complete (or returns immediately if already completed).:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="c1">// Data to be sent</span>
<span class="kt">float</span> <span class="n">my_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="c1">// Buffer to receive data</span>
<span class="kt">float</span> <span class="n">incoming_data</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="c1">// Register it in the BSP system</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">incoming_data</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="c1">// Get an address for the incoming_data buffer on the core with pid s + 1.</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">remote_data</span> <span class="o">=</span> <span class="n">ebsp_get_direct_address</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incoming_data</span><span class="p">);</span>

<span class="c1">// Start the DMA to copy the data from my_data on this core to incoming_data on the next core</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor</span><span class="p">;</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">remote_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">my_data</span><span class="p">));</span>

<span class="c1">// Do lengthy computation</span>
<span class="n">do_computations</span><span class="p">();</span>

<span class="c1">// Wait for the DMA transfer to finish</span>
<span class="n">ebsp_dma_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">);</span>

<span class="c1">// Done</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="interface">
<h4>Interface<a class="headerlink" href="#interface" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv315ebsp_ext_mallocj">
<span id="_CPPv215ebsp_ext_mallocj"></span><span id="ebsp_ext_malloc__unsigned-i"></span><span class="target" id="e__bsp_8h_1a36d7a889aaceb60fa730cbbc434803a6"></span>void *<code class="descname">ebsp_ext_malloc</code><span class="sig-paren">(</span>unsigned int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv315ebsp_ext_mallocj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate external memory. </p>
<p><p>This function allocates memory in external RAM, meaning the memory is slow and should not be used with time critical computations.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the allocated memory, guaranteed to be 8-byte aligned to ensure fast transfers, or zero on error.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the memory block </li>
</ul>
</dd>
</dl>
</p>
<p>When no more space is available, the function will return zero. Note that it is not allowed to call <a class="reference internal" href="index.html#e__bsp_8h_1a20a3b8f183945f4b5ead68f4549e99df"><span class="std std-ref">ebsp_free()</span></a> with a zero pointer so this should always be checked. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv311ebsp_mallocj">
<span id="_CPPv211ebsp_mallocj"></span><span id="ebsp_malloc__unsigned-i"></span><span class="target" id="e__bsp_8h_1ae24da840f5ceb1d602a68fc820817014"></span>void *<code class="descname">ebsp_malloc</code><span class="sig-paren">(</span>unsigned int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv311ebsp_mallocj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allocate local memory. </p>
<p><p>This function allocates memory in local SRAM, meaning the memory is fast but extremely limited.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the allocated memory, guaranteed to be 8-byte aligned to ensure fast transfers, or zero on error.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the memory block </li>
</ul>
</dd>
</dl>
</p>
<p>When no more space is available, the function will return zero. Note that it is not allowed to call <a class="reference internal" href="index.html#e__bsp_8h_1a20a3b8f183945f4b5ead68f4549e99df"><span class="std std-ref">ebsp_free()</span></a> with a zero pointer so this should always be checked. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39ebsp_freePv">
<span id="_CPPv29ebsp_freePv"></span><span id="ebsp_free__voidP"></span><span class="target" id="e__bsp_8h_1a20a3b8f183945f4b5ead68f4549e99df"></span>void <code class="descname">ebsp_free</code><span class="sig-paren">(</span>void *<em>ptr</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39ebsp_freePv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Free allocated external or local memory. </p>
<p><p>Note that the malloc functions can return null pointers on error, and ebsp_free will crash on null pointers. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: A pointer to memory previously allocated by <a class="reference internal" href="index.html#e__bsp_8h_1a36d7a889aaceb60fa730cbbc434803a6"><span class="std std-ref">ebsp_ext_malloc()</span></a> or by <a class="reference internal" href="index.html#e__bsp_8h_1ae24da840f5ceb1d602a68fc820817014"><span class="std std-ref">ebsp_malloc()</span></a></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv311ebsp_memcpyPvPKv6size_t">
<span id="_CPPv211ebsp_memcpyPvPKv6size_t"></span><span id="ebsp_memcpy__voidP.voidCP.s"></span><span class="target" id="e__bsp_8h_1adc3229240bd5a078502645d9354064ae"></span>void <code class="descname">ebsp_memcpy</code><span class="sig-paren">(</span>void *<em>dst</em>, <em class="property">const</em> void *<em>src</em>, size_t <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv311ebsp_memcpyPvPKv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performs a memory copy completely analogous to the standard C memcpy(). </p>
<p><p>This function is provided because the default </p>
<code class="docutils literal notranslate"><span class="pre">memcpy</span></code> generated by the epiphany-gcc compiler has some drawbacks. First of all it is stored in external memory, unless you store the full C library (newlib) on the epiphany cores. Secondly it does not do the optimal 8-byte transfers so it is far from optimal.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: Destination address </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: Source address </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: Amount of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p>This function resides in local core memory and does 8-byte transfers when possible, meaning if both <code class="docutils literal notranslate"><span class="pre">dst</span></code> and <code class="docutils literal notranslate"><span class="pre">src</span></code> are 8-byte aligned. In other cases, 4-byte or single byte transfers are used. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t">
<span id="_CPPv213ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t"></span><span id="ebsp_dma_push__ebsp_dma_handleP.voidP.voidCP.s"></span><span class="target" id="e__bsp_8h_1a420af4fdfd05e96d2772c3faa5e4f2d7"></span>void <code class="descname">ebsp_dma_push</code><span class="sig-paren">(</span>ebsp_dma_handle *<em>desc</em>, void *<em>dst</em>, <em class="property">const</em> void *<em>src</em>, size_t <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Push a new task to the DMA engine. </p>
<p>See the documentation on Memory Management for details on the DMA engine. <div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Source <code class="docutils literal notranslate"><span class="pre">src</span></code> and destination <code class="docutils literal notranslate"><span class="pre">dst</span></code> can <strong>NOT</strong> be both on the local
core. Doing so results in undefined behaviour. At least one of the two
addresses should be on another core or in external memory.</p>
</div>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc</span></code>: Used in combination with <a class="reference internal" href="index.html#e__bsp_8h_1aa6f8f0141eadd19b4c541de4c4cbcdd1"><span class="std std-ref">ebsp_dma_wait()</span></a>. Should be seen as a <em>handle</em> to the task. Its contents are populated by this function. </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: Destination address </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: Source address </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: Amount of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p>Assumes previous task in <code class="docutils literal notranslate"><span class="pre">desc</span></code> is completed (use <a class="reference internal" href="index.html#e__bsp_8h_1aa6f8f0141eadd19b4c541de4c4cbcdd1"><span class="std std-ref">ebsp_dma_wait()</span></a>)</p>
<p>The DMA (<code class="docutils literal notranslate"><span class="pre">E_DMA_1</span></code>) will be started if it was not started yet. If it was already started, this task will be pushed to a queue so that it will be done some time later. Use <a class="reference internal" href="index.html#e__bsp_8h_1aa6f8f0141eadd19b4c541de4c4cbcdd1"><span class="std std-ref">ebsp_dma_wait()</span></a> to wait for the task to complete.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="c1">// Data to be sent</span>
<span class="kt">float</span> <span class="n">mydata</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="c1">// Buffer to receive data</span>
<span class="kt">float</span> <span class="n">incomingdata</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="c1">// Register it in the BSP system</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incomingdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">incomingdata</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="c1">// Get an address for the incomingdata buffer on the core with pid s + 1.</span>
<span class="kt">float</span><span class="o">*</span> <span class="n">remotedata</span> <span class="o">=</span> <span class="n">ebsp_get_direct_address</span><span class="p">((</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">incomingdata</span><span class="p">);</span>

<span class="c1">// Start the DMA to copy the data from mydata on this core to incomingdata on the next core</span>
<span class="n">ebsp_dma_handle</span> <span class="n">descriptor</span><span class="p">;</span>
<span class="n">ebsp_dma_push</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span> <span class="n">remotedata</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mydata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mydata</span><span class="p">));</span>

<span class="c1">// Do lengthy computation</span>
<span class="n">do_computations</span><span class="p">();</span>

<span class="c1">// Wait for the DMA transfer to finish</span>
<span class="n">ebsp_dma_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">);</span>

<span class="c1">// Done</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">desc</span></code> pointer should be 8-byte aligned or behaviour is undefined. This should not be a problem because the malloc functions always return 8-byte aligned pointers, and having an <code class="docutils literal notranslate"><span class="pre">ebsp_dma_handle</span></code> struct as local variable will be 8-byte aligned as well. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv313ebsp_dma_waitP15ebsp_dma_handle">
<span id="_CPPv213ebsp_dma_waitP15ebsp_dma_handle"></span><span id="ebsp_dma_wait__ebsp_dma_handleP"></span><span class="target" id="e__bsp_8h_1aa6f8f0141eadd19b4c541de4c4cbcdd1"></span>void <code class="descname">ebsp_dma_wait</code><span class="sig-paren">(</span>ebsp_dma_handle *<em>desc</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv313ebsp_dma_waitP15ebsp_dma_handle" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for the task to be completed. </p>
<p><p>This function blocks untill the task in </p>
<code class="docutils literal notranslate"><span class="pre">desc</span></code> is completed. Use somewhere after <a class="reference internal" href="index.html#e__bsp_8h_1a420af4fdfd05e96d2772c3faa5e4f2d7"><span class="std std-ref">ebsp_dma_push()</span></a>. See <a class="reference internal" href="index.html#e__bsp_8h_1a420af4fdfd05e96d2772c3faa5e4f2d7"><span class="std std-ref">ebsp_dma_push()</span></a> for example code. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc</span></code>: Handle for a task. See <a class="reference internal" href="index.html#e__bsp_8h_1a420af4fdfd05e96d2772c3faa5e4f2d7"><span class="std std-ref">ebsp_dma_push()</span></a>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv323ebsp_get_direct_addressiPKv">
<span id="_CPPv223ebsp_get_direct_addressiPKv"></span><span id="ebsp_get_direct_address__i.voidCP"></span><span class="target" id="e__bsp_8h_1ab54296d8550bf8abab50c9b5e1854682"></span>void *<code class="descname">ebsp_get_direct_address</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>variable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv323ebsp_get_direct_addressiPKv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a raw remote memory address for a variable that was registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </p>
<p><p>The returned pointer (if nonzero) can be written to and read from directly. Note that the data will be transferred directly, as in </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a>, so synchronization issues should be considered.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to the remote variable, or 0 if it was not registered</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: Remote core id </li>
<li><code class="docutils literal notranslate"><span class="pre">variable</span></code>: An address that was registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
</ul>
</dd>
</dl>
</p>
<p>This function is meant to be used in combination with <a class="reference internal" href="index.html#e__bsp_8h_1a420af4fdfd05e96d2772c3faa5e4f2d7"><span class="std std-ref">ebsp_dma_push()</span></a> to transfer data between cores while doing computations at the same time. </p>
</dd></dl>

</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-memory_details"></span><div class="section" id="parallella-memory-details">
<span id="memory-details"></span><h3>Parallella Memory Details<a class="headerlink" href="#parallella-memory-details" title="Permalink to this headline">¶</a></h3>
<p>This page is meant for people who want to understand the different types of memory that are available on the Parallella. It does not contain required knowledge for those who only want to use the Epiphany BSP library.</p>
<p>This page tries to take away any confusion about the different types of memory available for the Epiphany cores and explain the terminology that is being used in the community.</p>
<p>An Epiphany core is sometimes referred to as a <strong>mesh node</strong> since the network of cores is called a <strong>mesh network</strong>.</p>
<div class="section" id="memory-types">
<h4>Memory Types<a class="headerlink" href="#memory-types" title="Permalink to this headline">¶</a></h4>
<p>The Epiphany cores have access to two types of memory.
Both types can be accessed directly (e.g. by dereferencing a pointer). Here we will give a short overview of these two types. For more details see the <a class="reference external" href="http://www.adapteva.com/docs/epiphany_arch_ref.pdf">Epiphany architecture reference</a>.</p>
<p>All addresses shown below are the ones used by the Epiphany cores. They can <strong>not</strong> be used directly by the ARM processor.</p>
<div class="section" id="internal-memory">
<h5>Internal memory<a class="headerlink" href="#internal-memory" title="Permalink to this headline">¶</a></h5>
<p><strong>Size</strong>: 32KB (<code class="docutils literal notranslate"><span class="pre">0x8000</span></code>) per core</p>
<p>Location in address space:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">0x00000000</span> <span class="pre">-</span> <span class="pre">0x00007fff</span></code> when a core is referring to its own memory</li>
<li><code class="docutils literal notranslate"><span class="pre">0x???00000</span> <span class="pre">-</span> <span class="pre">0x???07fff</span></code> when referring to the memory of any other core (or itself). The <code class="docutils literal notranslate"><span class="pre">???</span></code> indicates the Epiphany core, using 6 bits for the row and 6 bits for the column.</li>
</ul>
<p>Terminology:</p>
<ul class="simple">
<li>Internal memory</li>
<li>eCore memory</li>
<li>SRAM or Static RAM. Not to be confused with Shared RAM.</li>
</ul>
<p>Usage:</p>
<ul class="simple">
<li>Program code, starting at lower addresses</li>
<li>Program data (global variables), starting at lower addresses after code</li>
<li>Stack (local variables), starting at <code class="docutils literal notranslate"><span class="pre">0x8000</span></code> expanding downwards</li>
</ul>
</div>
<div class="section" id="external-memory">
<h5>External memory<a class="headerlink" href="#external-memory" title="Permalink to this headline">¶</a></h5>
<p><strong>Size</strong>: 32 MB (<code class="docutils literal notranslate"><span class="pre">0x02000000</span></code>) shared over all cores</p>
<p>Location in address space:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">0x8e000000</span> <span class="pre">-</span> <span class="pre">0x8fffffff</span></code></li>
</ul>
<p>Terminology:</p>
<ul class="simple">
<li>External memory</li>
<li>Shared memory</li>
<li>DRAM or Dynamic RAM</li>
<li>SDRAM or Shared DRAM</li>
</ul>
<p>Usage:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some of the following information depends on the linker script that is being used. The information below is valid when using the <code class="docutils literal notranslate"><span class="pre">fast.ldf</span></code> linkerscript.</p>
</div>
<ul>
<li><p class="first"><strong>Location</strong>: <code class="docutils literal notranslate"><span class="pre">0x8e000000</span> <span class="pre">-</span> <span class="pre">0x8effffff</span></code></p>
<p><strong>Size</strong>:<code class="docutils literal notranslate"><span class="pre">0x01000000</span></code> (16 MB)</p>
<p><strong>Contents</strong>: newlib (the C library, with code, data, stack)</p>
</li>
<li><p class="first"><strong>Location</strong>: <code class="docutils literal notranslate"><span class="pre">0x8f000000</span> <span class="pre">-</span> <span class="pre">0x8fffffff</span></code></p>
<p><strong>Size</strong>:<code class="docutils literal notranslate"><span class="pre">0x01000000</span></code> (16 MB)</p>
<p><strong>Contents</strong>:</p>
<ul>
<li><p class="first"><strong>Location</strong>:  <code class="docutils literal notranslate"><span class="pre">0x8f000000</span> <span class="pre">-</span> <span class="pre">0x8f7fffff</span></code></p>
<p><strong>Size</strong>: <code class="docutils literal notranslate"><span class="pre">0x00800000</span></code> (8 MB)</p>
<p><strong>Section label</strong>: <code class="docutils literal notranslate"><span class="pre">shared_dram</span></code> (see below for section info)</p>
<p><strong>Contents</strong>: used by the <code class="docutils literal notranslate"><span class="pre">e_shm_xxx</span></code> functions of the ESDK</p>
<p><strong>Extra info</strong>: The C function <code class="docutils literal notranslate"><span class="pre">malloc</span></code> returns addresses from this region (possibly a bug?) which causes this region to be corrupted if one uses any C function that uses malloc internally. This region is for example altered when calling any <code class="docutils literal notranslate"><span class="pre">printf</span></code> variant with a floating point specifier <code class="docutils literal notranslate"><span class="pre">&quot;%f&quot;</span></code> in the string.</p>
</li>
<li><p class="first"><strong>Location</strong>:  <code class="docutils literal notranslate"><span class="pre">0x8f800000</span> <span class="pre">-</span> <span class="pre">0x8fffffff</span></code></p>
<p><strong>Size</strong>: <code class="docutils literal notranslate"><span class="pre">0x00800000</span></code> (8 MB)</p>
<p><strong>Section label</strong>: <code class="docutils literal notranslate"><span class="pre">heap_dram</span></code> (see below for section info)</p>
<p><strong>Contents</strong>: is meant to be divided in 512KB for each core (<code class="docutils literal notranslate"><span class="pre">16</span> <span class="pre">*</span> <span class="pre">512KB</span> <span class="pre">=</span> <span class="pre">8MB</span></code>) and then used for <code class="docutils literal notranslate"><span class="pre">malloc</span></code> but this does <strong>not</strong> currently work. Instead <code class="docutils literal notranslate"><span class="pre">malloc</span></code> returns addresses from <code class="docutils literal notranslate"><span class="pre">shared_dram</span></code></p>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="accessing-the-memory-from-the-epiphany-cores">
<h4>Accessing the memory from the Epiphany cores<a class="headerlink" href="#accessing-the-memory-from-the-epiphany-cores" title="Permalink to this headline">¶</a></h4>
<div class="section" id="normal-access">
<h5>Normal access<a class="headerlink" href="#normal-access" title="Permalink to this headline">¶</a></h5>
<p>All types of memory can be accessed by for example dereferencing a pointer to an address.
If one does not want to hardcode addresses, <strong>section labels</strong> can be used to put data in certain sections, in the following way:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">//Internal memory</span>
<span class="kt">char</span> <span class="n">my_char</span><span class="p">;</span> <span class="c1">//normal method</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">my_other_char</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mh">0x6000</span><span class="p">;</span> <span class="c1">//hardcoding addresses</span>

<span class="c1">//External memory using section labels</span>
<span class="kt">int</span> <span class="n">my_integer</span> <span class="nf">SECTION</span><span class="p">(</span><span class="s">&quot;shared_dram&quot;</span><span class="p">);</span> <span class="c1">//section at 0x8f000000</span>
<span class="kt">float</span> <span class="n">my_float</span> <span class="nf">SECTION</span><span class="p">(</span><span class="s">&quot;heap_dram&quot;</span><span class="p">);</span> <span class="c1">//section at 0x8f800000</span>
<span class="c1">//External memory using hardcoded addresses</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">my_other_integer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mh">0x8f000000</span><span class="p">;</span>
<span class="kt">float</span> <span class="o">*</span><span class="n">my_other_float</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="mh">0x8f800000</span><span class="p">;</span>
</pre></div>
</div>
<p>If one wants to read or write to another core’s memory, the ESDK functions <code class="docutils literal notranslate"><span class="pre">e_read</span></code> and <code class="docutils literal notranslate"><span class="pre">e_write</span></code> can be used, which will compute the correct address (of the form <code class="docutils literal notranslate"><span class="pre">0x???00000</span> <span class="pre">+</span> <span class="pre">offset</span></code>) and memcpy the data.
Alternatively one can use <a class="reference internal" href="index.html#_CPPv323ebsp_get_direct_addressiPKv" title="ebsp_get_direct_address"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_get_direct_address()</span></code></a> to get a direct pointer to the data on the remote core.</p>
</div>
<div class="section" id="dma-engine">
<h5>DMA Engine<a class="headerlink" href="#dma-engine" title="Permalink to this headline">¶</a></h5>
<p>Each Epiphany processor contains a <em>DMA engine</em> which can be used to transfer data.
The advantage of the DMA engine over normal memory access is that the DMA engine is <strong>faster</strong> and can transfer data <strong>while the CPU does other things</strong>. There are <strong>two DMA channels</strong>, meaning that two pairs of source/destination addresses can be set and the CPU can continue while the DMA engine is transfering data. This source and destination addresses can even <em>both be pointing at other cores’ internal memory</em>.
To use the DMA engine one can use the <code class="docutils literal notranslate"><span class="pre">e_dma_xxx</span></code> functions from the ESDK. When writing EBSP programs you should prefer <a class="reference internal" href="index.html#_CPPv313ebsp_dma_pushP15ebsp_dma_handlePvPKv6size_t" title="ebsp_dma_push"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ebsp_dma_push()</span></code></a> to let the EBSP system manage the DMA engine.</p>
</div>
<div class="section" id="accessing-the-memory-directly-from-the-arm-processor">
<h5>Accessing the memory directly from the ARM processor<a class="headerlink" href="#accessing-the-memory-directly-from-the-arm-processor" title="Permalink to this headline">¶</a></h5>
<p>The EBSP library supports a number of ways to write to the Epiphany cores. If for some reason you want to use the ESDK directly, you can use <code class="docutils literal notranslate"><span class="pre">e_read</span></code> and <code class="docutils literal notranslate"><span class="pre">e_write</span></code> ESDK functions in order to write to the internal memory of each core.</p>
<p>To write to external memory, one has to use <code class="docutils literal notranslate"><span class="pre">e_alloc</span></code> to “allocate” external memory. This function does not actually <strong>allocate</strong> memory (it is already there), it _only_ gives you a <code class="docutils literal notranslate"><span class="pre">e_mem_t</span></code> struct that allows you to access the memory with <code class="docutils literal notranslate"><span class="pre">e_read</span></code> and <code class="docutils literal notranslate"><span class="pre">e_write</span></code> calls.
The <code class="docutils literal notranslate"><span class="pre">offset</span></code> that you pass to <code class="docutils literal notranslate"><span class="pre">e_alloc</span></code> will be an offset from <code class="docutils literal notranslate"><span class="pre">0x8e000000</span></code>, meaning an offset of <code class="docutils literal notranslate"><span class="pre">0x01000000</span></code> will give you access to the external memory at <code class="docutils literal notranslate"><span class="pre">0x8e000000</span> <span class="pre">+</span> <span class="pre">0x01000000</span> <span class="pre">=</span> <span class="pre">0x8f000000</span> <span class="pre">(shared_dram)</span></code> as seen from the Epiphany. Subsequent offsets can then be added on top of this in <code class="docutils literal notranslate"><span class="pre">e_read</span></code> and <code class="docutils literal notranslate"><span class="pre">e_write</span></code> calls.</p>
</div>
</div>
<div class="section" id="memory-speed">
<h4>Memory speed<a class="headerlink" href="#memory-speed" title="Permalink to this headline">¶</a></h4>
<p>To give an idea of the efficiency of the types of memory, we share here benchmark data that has been taken from
<a class="reference external" href="https://parallella.org/forums/viewtopic.php?f=23&amp;t=307&amp;sid=773cf3c3fc58f303645cfe0a684965a7">https://parallella.org/forums/viewtopic.php?f=23&amp;t=307&amp;sid=773cf3c3fc58f303645cfe0a684965a7</a></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">SRAM</span> <span class="o">=</span> <span class="n">Internal</span> <span class="n">memory</span>
<span class="n">ERAM</span> <span class="o">=</span> <span class="n">External</span> <span class="n">memory</span>

<span class="n">Host</span> <span class="o">-&gt;</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span>   <span class="mf">14.62</span> <span class="n">MBps</span>
<span class="n">Host</span> <span class="o">&lt;-</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>   <span class="mf">17.85</span> <span class="n">MBps</span>
<span class="n">Host</span> <span class="o">-&gt;</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span>  <span class="mf">100.71</span> <span class="n">MBps</span>
<span class="n">Host</span> <span class="o">&lt;-</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>  <span class="mf">135.42</span> <span class="n">MBps</span>

<span class="n">Using</span> <span class="nl">memcpy</span><span class="p">:</span>
<span class="n">Core</span> <span class="o">-&gt;</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span>  <span class="mf">504.09</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">9299</span>
<span class="n">Core</span> <span class="o">&lt;-</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>  <span class="mf">115.65</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">40531</span>
<span class="n">Core</span> <span class="o">-&gt;</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span>  <span class="mf">142.99</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">32782</span>
<span class="n">Core</span> <span class="o">&lt;-</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>    <span class="mf">4.19</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">1119132</span>

<span class="n">Using</span> <span class="nl">DMA</span><span class="p">:</span>
<span class="n">Core</span> <span class="o">-&gt;</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span> <span class="mf">1949.88</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">2404</span>
<span class="n">Core</span> <span class="o">&lt;-</span> <span class="nl">SRAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>  <span class="mf">480.82</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">9749</span>
<span class="n">Core</span> <span class="o">-&gt;</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Write</span> <span class="n">speed</span> <span class="o">=</span>  <span class="mf">493.21</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">9504</span>
<span class="n">Core</span> <span class="o">&lt;-</span> <span class="nl">ERAM</span><span class="p">:</span> <span class="n">Read</span> <span class="n">speed</span>  <span class="o">=</span>  <span class="mf">154.52</span> <span class="n">MBps</span> <span class="n">clocks</span> <span class="o">=</span> <span class="mi">30336</span>
</pre></div>
</div>
</div>
</div>
<span id="document-bsp"></span><div class="section" id="bsp-model">
<h3>BSP Model<a class="headerlink" href="#bsp-model" title="Permalink to this headline">¶</a></h3>
<p>The Bulk Synchronous Parallel (BSP) model was developed by Leslie Valiant in the 1980s. The BSP model is intended as a bridging model between parallel hardware and software. It is an elegant and simple model that has a small and easy to understand interface.</p>
<p>The BSP model is defined on an abstract computer called a BSP computer. This computer has three important requirements.</p>
<ol class="arabic simple">
<li>It has <span class="math notranslate nohighlight">\(n\)</span> processors capable of computation and communication, i.e. it allows for local memory transactions.</li>
<li>It has a network in place that allows the different processors to send and receive data.</li>
<li>It has a mechanism that allows for the synchronisation of these processors, e.g. by means of a blocking barrier.</li>
</ol>
<p>A BSP program consists of a number of distinct blocks of computation and communication called <em>supersteps</em>. These steps are separated by a barrier synchronisation, and consist of a computation and a communication step.</p>
<p>An important part of a BSP algorithm is the associated cost function. To this end we introduce two important concepts: namely an <span class="math notranslate nohighlight">\(h\)</span>-relation, and a notion of the <em>work</em> done by a processor. Furthermore we introduce two parameters that define a BSP computer: <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(l\)</span>.</p>
<p>An <span class="math notranslate nohighlight">\(h\)</span>-relation is a superstep in which each processor sends or receives a maximum of <span class="math notranslate nohighlight">\(h\)</span> words of data. We commonly denote with <span class="math notranslate nohighlight">\(p\)</span> the id of a processor such that we can write for the <span class="math notranslate nohighlight">\(h\)</span>-relation:</p>
<div class="math notranslate nohighlight">
\[h = \max_p \left\{ \max \{ (h_p)_\text{sent}, (h_p)_\text{received} \}~|~\text{processors } p \right\}\]</div>
<p>Where <span class="math notranslate nohighlight">\(h_p\)</span> denotes the number of words received or sent by processor <span class="math notranslate nohighlight">\(p\)</span>. Similarly we define the work <span class="math notranslate nohighlight">\(w\)</span> done in a superstep as the maximum number of flops, floating point operations, performed by all processors. Finally we define the latency <span class="math notranslate nohighlight">\(l\)</span> of a superstep as the fixed constant overhead, used primarily to account for the barrier synchronisation. The values for <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(l\)</span> are platform-specific constants that are found emperically. The values for <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(h\)</span> are superstep specific and commonly obtained analytically. The total BSP cost associated to a BSP algorithm is:</p>
<div class="math notranslate nohighlight">
\[T = \sum_{\text{supersteps } i} (w_i + g \cdot h_i + l)\]</div>
<p>The BSP model has gained significant interest in the last couple of years. Most notably because Google has adopted the model and has developed some technologies based on BSP such as MapReduce and Pregel. The standard for BSP implementations is <a class="reference external" href="http://www.bsp-worldwide.org/">BSPlib</a>. Modern implementations of the BSP model include BSPonMPI, which simulates the BSP model on top of MPI, and MulticoreBSP, which provides a BSP implementation for shared-memory multi-core computers.</p>
<p>For a more detailed introduction on the BSP model, as well as a large number of examples of BSP programs we refer to the <a class="reference external" href="http://ukcatalogue.oup.com/product/9780198529392.do">introductory textbook on BSP and MPI</a> by Rob Bisseling.</p>
<p>A large number of algorithms have already been implemented using the BSP model. Some of them with their associated cost function are listed below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="54%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Problem</th>
<th class="head">BSP Complexity</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Matrix multiplication</td>
<td><span class="math notranslate nohighlight">\(n^3/p + (n^2/p^{2/3}) \cdot g + l\)</span></td>
</tr>
<tr class="row-odd"><td>Sorting</td>
<td><span class="math notranslate nohighlight">\((n \log n)/p + (n/p)\cdot g + l\)</span></td>
</tr>
<tr class="row-even"><td>Fast Fourier Transform</td>
<td><span class="math notranslate nohighlight">\((n \log n)/p + (n/p)\cdot g + l\)</span></td>
</tr>
<tr class="row-odd"><td>LU Decomposition</td>
<td><span class="math notranslate nohighlight">\(n^3/p + (n^2/p^{1/2})\cdot g + p^{1/2}\cdot l\)</span></td>
</tr>
<tr class="row-even"><td>Cholesky Factorisation</td>
<td><span class="math notranslate nohighlight">\(n^3/p + (n^2/p^{1/2})\cdot g + p^{1/2}\cdot l\)</span></td>
</tr>
<tr class="row-odd"><td>Algebraic Path Problem (Shortest Paths)</td>
<td><span class="math notranslate nohighlight">\(n^3/p + (n^2/p^{1/2})\cdot g + p^{1/2}\cdot l\)</span></td>
</tr>
<tr class="row-even"><td>Triangular Solver</td>
<td><span class="math notranslate nohighlight">\(n^2/p + n\cdot g + p\cdot l\)</span></td>
</tr>
<tr class="row-odd"><td>String Edit Problem</td>
<td><span class="math notranslate nohighlight">\(n^2/p + n\cdot g + p\cdot l\)</span></td>
</tr>
<tr class="row-even"><td>Dense Matrix-Vector Multiplication</td>
<td><span class="math notranslate nohighlight">\(n^2/p + (n/p^{1/2})\cdot g+l\)</span></td>
</tr>
<tr class="row-odd"><td>Sparse Matrix-Vector Multiplication (2D grid)</td>
<td><span class="math notranslate nohighlight">\(n/p + (n/p)^{1/2}\cdot g+l\)</span></td>
</tr>
<tr class="row-even"><td>Sparse Matrix-Vector Multiplication (3D grid)</td>
<td><span class="math notranslate nohighlight">\(n/p + (n/p)^{2/3}\cdot g+l\)</span></td>
</tr>
<tr class="row-odd"><td>Sparse Matrix-Vector Multiplication (random)</td>
<td><span class="math notranslate nohighlight">\(n/p + (n/p)\cdot g+l\)</span></td>
</tr>
<tr class="row-even"><td>List Ranking</td>
<td><span class="math notranslate nohighlight">\(n/p + (n/p)\cdot g+(\log p)\cdot l\)</span></td>
</tr>
</tbody>
</table>
<p><em>(From: McColl 1998 “Foundations of Time-Critical Scalable Computing”)</em></p>
</div>
<span id="document-api_reference"></span><div class="section" id="api-reference">
<h3>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h3>
<p>On this page we give a complete overview of all the primitives we expose in the main EBSP library.</p>
<div class="section" id="host">
<h4>Host<a class="headerlink" href="#host" title="Permalink to this headline">¶</a></h4>
<div class="section" id="bsp-init">
<h5>bsp_init<a class="headerlink" href="#bsp-init" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_initPKciPPc">
<span id="_CPPv28bsp_initPKciPPc"></span><span id="bsp_init__cCP.i.cPP"></span><span class="target" id="host__bsp_8h_1a0e3c4e8b772e2ed3d8b231289d694e9c"></span>int <code class="descname">bsp_init</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>e_name</em>, int <em>argc</em>, char **<em>argv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv38bsp_initPKciPPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Initializes the BSP system. </p>
<p><p>Sets up all the BSP variables and loads the epiphany BSP program.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e_name</span></code>: A string with the srec binary name of the Epiphany program </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: The number of input arguments </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: An array of strings with the input arguments </li>
</ul>
</dd>
</dl>
</p>
<p>The string <code class="docutils literal notranslate"><span class="pre">e_name</span></code> must be of the form <code class="docutils literal notranslate"><span class="pre">myprogram.srec</span></code>. This function will search for the file in the same directory as the host program, and not in the current working directory.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">argc</span></code> and <code class="docutils literal notranslate"><span class="pre">argv</span></code> parameters are ignored in the current implementation. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-spmd">
<h5>ebsp_spmd<a class="headerlink" href="#ebsp-spmd" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39ebsp_spmdv">
<span id="_CPPv29ebsp_spmdv"></span><span id="ebsp_spmd"></span><span class="target" id="host__bsp_8h_1a12385c882b6096484952fe7acad958bd"></span>int <code class="descname">ebsp_spmd</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39ebsp_spmdv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Runs the Epiphany program on the Epiphany cores. </p>
<p><p>This function will block until the BSP kernel program is finished. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure (e.g. after <code class="docutils literal notranslate"><span class="pre">bsp_abort</span></code> is called on a core)</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-begin">
<h5>bsp_begin<a class="headerlink" href="#bsp-begin" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_begini">
<span id="_CPPv29bsp_begini"></span><span id="bsp_begin__i"></span><span class="target" id="host__bsp_8h_1a6e8b0d677de36ad531e72b212e45f14e"></span>int <code class="descname">bsp_begin</code><span class="sig-paren">(</span>int <em>nprocs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_begini" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Loads the BSP program onto the Epiphany cores. </p>
<p><p>Usage example: </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">bsp_begin</span><span class="p">(</span><span class="n">bsp_nprocs</span><span class="p">());</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nprocs</span></code>: The number of processors to run on </li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The current implementation only allows <code class="docutils literal notranslate"><span class="pre">nprocs</span></code> to be a multiple of 4 on the 16-core Parallella. Other values of <code class="docutils literal notranslate"><span class="pre">nprocs</span></code> are rounded down. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-end">
<h5>bsp_end<a class="headerlink" href="#bsp-end" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv37bsp_endv">
<span id="_CPPv27bsp_endv"></span><span id="bsp_end"></span><span class="target" id="host__bsp_8h_1a56a290cf0e1b78c832024cd5399f46d0"></span>int <code class="descname">bsp_end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv37bsp_endv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finalizes and cleans up the BSP program. </p>
<p><p>Usage example: </p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bsp_init</span><span class="p">(</span><span class="s">&quot;e_program.srec&quot;</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">bsp_begin</span><span class="p">(</span><span class="n">bsp_nprocs</span><span class="p">());</span>
    <span class="n">ebsp_spmd</span><span class="p">();</span>
    <span class="n">bsp_end</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function is different from the bsp_end function in e_bsp.h </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-nprocs">
<h5>bsp_nprocs<a class="headerlink" href="#bsp-nprocs" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310bsp_nprocsv">
<span id="_CPPv210bsp_nprocsv"></span><span id="bsp_nprocs"></span><span class="target" id="host__bsp_8h_1a8980a3403ba99114626b34492b13c1cd"></span>int <code class="descname">bsp_nprocs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv310bsp_nprocsv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of available processors (Epiphany cores). </p>
<p><p>This function may be called after </p>
<a class="reference internal" href="index.html#host__bsp_8h_1a0e3c4e8b772e2ed3d8b231289d694e9c"><span class="std std-ref">bsp_init()</span></a>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of available processors</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-set-tagsize">
<h5>ebsp_set_tagsize<a class="headerlink" href="#ebsp-set-tagsize" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv316ebsp_set_tagsizePi">
<span id="_CPPv216ebsp_set_tagsizePi"></span><span id="ebsp_set_tagsize__iP"></span><span class="target" id="host__bsp_8h_1a27bb2cce1a92dbf95ab28ea662216370"></span>void <code class="descname">ebsp_set_tagsize</code><span class="sig-paren">(</span>int *<em>tag_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv316ebsp_set_tagsizePi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set initial tagsize for message passing. </p>
<p><p>The default tagsize is zero. This function should be called at most once, before any messages are sent. Calling this when receiving messages results in undefined behaviour.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_bytes</span></code>: A pointer to an integer containing the new tagsize, receiving the old tagsize on return.</li>
</ul>
</dd>
</dl>
</p>
<p>It is not possible to send messages with different tag sizes. Doing so will result in undefined behaviour.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The tagsize set using this function is also used for inter-core messages. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-send-down">
<h5>ebsp_send_down<a class="headerlink" href="#ebsp-send-down" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv314ebsp_send_downiPKvPKvi">
<span id="_CPPv214ebsp_send_downiPKvPKvi"></span><span id="ebsp_send_down__i.voidCP.voidCP.i"></span><span class="target" id="host__bsp_8h_1ae51209685120c4965c41b2056fee1872"></span>void <code class="descname">ebsp_send_down</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>tag</em>, <em class="property">const</em> void *<em>payload</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv314ebsp_send_downiPKvPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a message to the Epiphany cores. </p>
<p><p>This is the preferred way to send initial data (for computation) to the Epiphany cores.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to the message tag </li>
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the payload in bytes</li>
</ul>
</dd>
</dl>
</p>
<p>The size of the buffer pointed to by tag has to be <code class="docutils literal notranslate"><span class="pre">tagsize</span></code>, and must be the same for every message being sent. </p>
</dd></dl>

</div>
<div class="section" id="ebsp-get-tagsize">
<h5>ebsp_get_tagsize<a class="headerlink" href="#ebsp-get-tagsize" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv316ebsp_get_tagsizev">
<span id="_CPPv216ebsp_get_tagsizev"></span><span id="ebsp_get_tagsize"></span><span class="target" id="host__bsp_8h_1a47cf6f4bc4ee48eddc146f52d7eb8f95"></span>int <code class="descname">ebsp_get_tagsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv316ebsp_get_tagsizev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the tagsize as set by the Epiphany program. </p>
<p><p>Use only for gathering result messages at the end of a BSP program.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The tagsize in bytes</dd>
</dl>
</p>
<p>When <a class="reference internal" href="index.html#host__bsp_8h_1a12385c882b6096484952fe7acad958bd"><span class="std std-ref">ebsp_spmd()</span></a> returns, the Epiphany program can have set a different tagsize which can be obtained using this function. </p>
</dd></dl>

</div>
<div class="section" id="ebsp-qsize">
<h5>ebsp_qsize<a class="headerlink" href="#ebsp-qsize" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310ebsp_qsizePiPi">
<span id="_CPPv210ebsp_qsizePiPi"></span><span id="ebsp_qsize__iP.iP"></span><span class="target" id="host__bsp_8h_1a0dc8a00e88a2ecb254bde2ec8665159e"></span>void <code class="descname">ebsp_qsize</code><span class="sig-paren">(</span>int *<em>packets</em>, int *<em>accum_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv310ebsp_qsizePiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the amount of messages in the queue and their total size in bytes. </p>
<p><p>Use only for gathering result messages at the end of a BSP program. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">packets</span></code>: A pointer to an integer receiving the number of messages </li>
<li><code class="docutils literal notranslate"><span class="pre">accum_bytes</span></code>: The total size of the data payloads of the messages, in bytes.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-get-tag">
<h5>ebsp_get_tag<a class="headerlink" href="#ebsp-get-tag" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv312ebsp_get_tagPiPv">
<span id="_CPPv212ebsp_get_tagPiPv"></span><span id="ebsp_get_tag__iP.voidP"></span><span class="target" id="host__bsp_8h_1a89a2c446c95a777ecad3e67150a072dd"></span>void <code class="descname">ebsp_get_tag</code><span class="sig-paren">(</span>int *<em>status</em>, void *<em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv312ebsp_get_tagPiPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Peek the next message. </p>
<p><p>Use only for gathering result messages at the end of a BSP program. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">status</span></code>: A pointer to an integer receiving the amount of bytes of the next message payload, or -1 if there are no more messages. </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to a buffer receiving the tag of the next message. This buffer should be large enough (<a class="reference internal" href="index.html#host__bsp_8h_1a47cf6f4bc4ee48eddc146f52d7eb8f95"><span class="std std-ref">ebsp_get_tagsize()</span></a>).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-move">
<h5>ebsp_move<a class="headerlink" href="#ebsp-move" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39ebsp_movePvi">
<span id="_CPPv29ebsp_movePvi"></span><span id="ebsp_move__voidP.i"></span><span class="target" id="host__bsp_8h_1af97081420510913465a16fc0826f51f8"></span>void <code class="descname">ebsp_move</code><span class="sig-paren">(</span>void *<em>payload</em>, int <em>buffer_size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39ebsp_movePvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next message from the message queue and pop the message. </p>
<p><p>This will copy the payload and pop the message from the queue. The size of the payload can be obtained by calling bsp_get_tag(). If </p>
<code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> is smaller than the data payload then the data is truncated.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to a buffer receiving the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code>: The size of the buffer</li>
</ul>
</dd>
</dl>
</p>
<p>Use only for gathering result messages at the end of a BSP program. </p>
</dd></dl>

</div>
<div class="section" id="ebsp-hpmove">
<h5>ebsp_hpmove<a class="headerlink" href="#ebsp-hpmove" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv311ebsp_hpmovePPvPPv">
<span id="_CPPv211ebsp_hpmovePPvPPv"></span><span id="ebsp_hpmove__voidPP.voidPP"></span><span class="target" id="host__bsp_8h_1ac5738a8e7a86659a238c9e90756dadc5"></span>int <code class="descname">ebsp_hpmove</code><span class="sig-paren">(</span>void **<em>tag_ptr_buf</em>, void **<em>payload_ptr_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv311ebsp_hpmovePPvPPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the next message, with tag, from the queue and pop the message. </p>
<p><p>This is the faster alternative of </p>
<a class="reference internal" href="index.html#host__bsp_8h_1af97081420510913465a16fc0826f51f8"><span class="std std-ref">ebsp_move()</span></a>, as this function does not copy the data but returns the pointers to it.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of bytes of the payload data</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_ptr_buf</span></code>: A pointer to a pointer receiving the location of the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">payload_ptr_buf</span></code>: A pointer to a pointer receiving the location of the data pyaload </li>
</ul>
</dd>
</dl>
</p>
<p>Use only for gathering result messages at the end of a BSP program. </p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-create">
<h5>bsp_stream_create<a class="headerlink" href="#bsp-stream-create" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv317bsp_stream_createiiPKv">
<span id="_CPPv217bsp_stream_createiiPKv"></span><span id="bsp_stream_create__i.i.voidCP"></span><span class="target" id="host__bsp_8h_1ae7db595dbbbfde687bc1a208e419a7d8"></span>void *<code class="descname">bsp_stream_create</code><span class="sig-paren">(</span>int <em>stream_size</em>, int <em>token_size</em>, <em class="property">const</em> void *<em>initial_data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv317bsp_stream_createiiPKv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a generic stream for streaming data to or from an Epiphany core. </p>
<p><p>The function returns NULL on failure.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A pointer to a section of external memory storing the tokens.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream_size</span></code>: The total number of bytes of data in the stream. </li>
<li><code class="docutils literal notranslate"><span class="pre">token_size</span></code>: The size in bytes of a single token. Must be at least 16. </li>
<li><code class="docutils literal notranslate"><span class="pre">initial_data</span></code>: (Optional) The data which should be streamed to an Epiphany core. </li>
</ul>
</dd>
</dl>
</p>
<p>If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is nonzero, it is copied to the stream (<code class="docutils literal notranslate"><span class="pre">stream_size</span></code> bytes). If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is zero, an empty stream of size <code class="docutils literal notranslate"><span class="pre">stream_size</span></code> is created. In this case, <code class="docutils literal notranslate"><span class="pre">stream_size</span></code> should be the maximum number of bytes that will be sent up from the Epiphany cores to the host.</p>
<p>This function prints an error if <code class="docutils literal notranslate"><span class="pre">token_size</span></code> is less than 16.</p>
<p>The format of the data pointed to by the return value is as follows: Before every token, there are two integers that specify the size of the preceding token and the size of the token itself.</p>
<p>00000000, nextsize, data, prevsize, nextsize, data, … prevsize, nextsize, data, prevsize, 00000000</p>
<p>So a header consists of two integers (8 byte total). The two sizes do NOT include these headers. They are only the size of the data inbetween.</p>
<p>If you want to use the returned pointer directly you have to manually take care of this data format.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">initial_data</span></code> is nonzero, the data is copied so that after the call it can safely be freed or overwritten by the user. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-write">
<h5>ebsp_write<a class="headerlink" href="#ebsp-write" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310ebsp_writeiPv5off_ti">
<span id="_CPPv210ebsp_writeiPv5off_ti"></span><span id="ebsp_write__i.voidP.off_t.i"></span><span class="target" id="host__bsp_8h_1a00f9d9253d6ffa496ee041955689c99a"></span>int <code class="descname">ebsp_write</code><span class="sig-paren">(</span>int <em>pid</em>, void *<em>src</em>, off_t <em>dst</em>, int <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv310ebsp_writeiPv5off_ti" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write data to the Epiphany processor. </p>
<p><p>This is an alternative to the BSP Message Passing system. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to the source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: The destination address (as seen by the Epiphany core) </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: The amount of bytes to be copied </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-read">
<h5>ebsp_read<a class="headerlink" href="#ebsp-read" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39ebsp_readi5off_tPvi">
<span id="_CPPv29ebsp_readi5off_tPvi"></span><span id="ebsp_read__i.off_t.voidP.i"></span><span class="target" id="host__bsp_8h_1a65423fcb58e7d782c3914a8689dc527f"></span>int <code class="descname">ebsp_read</code><span class="sig-paren">(</span>int <em>pid</em>, off_t <em>src</em>, void *<em>dst</em>, int <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39ebsp_readi5off_tPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read data from the Epiphany processor. </p>
<p><p>This is an alternative to the BSP Message Passing system. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>1 on success, 0 on failure</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the source processor </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: The source address (as seen by the Epiphany core) </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a buffer receiving the data </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: The amount of bytes to be copied </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-set-sync-callback">
<h5>ebsp_set_sync_callback<a class="headerlink" href="#ebsp-set-sync-callback" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv322ebsp_set_sync_callbackPFvvE">
<span id="_CPPv222ebsp_set_sync_callbackPFvvE"></span><span class="target" id="host__bsp_8h_1ad542fb7eba809cad18949b672708545b"></span>void <code class="descname">ebsp_set_sync_callback</code><span class="sig-paren">(</span>void (*<em>cb</em>)<span class="sig-paren">(</span><span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv322ebsp_set_sync_callbackPFvvE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the (optional) callback for synchronizing epiphany cores with the host program. </p>
<p><p>This callback is called when all Epiphany cores have called ebsp_host_sync(). Note that this does not happen at bsp_sync(). </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cb</span></code>: A function pointer to the callback function</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-set-end-callback">
<h5>ebsp_set_end_callback<a class="headerlink" href="#ebsp-set-end-callback" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv321ebsp_set_end_callbackPFvvE">
<span id="_CPPv221ebsp_set_end_callbackPFvvE"></span><span class="target" id="host__bsp_8h_1a96ce8db901942447741ee8d2ace5d161"></span>void <code class="descname">ebsp_set_end_callback</code><span class="sig-paren">(</span>void (*<em>cb</em>)<span class="sig-paren">(</span><span class="sig-paren">)</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv321ebsp_set_end_callbackPFvvE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the (optional) callback for finalizing. </p>
<p><p>This callback is called when </p>
<a class="reference internal" href="index.html#host__bsp_8h_1a12385c882b6096484952fe7acad958bd"><span class="std std-ref">ebsp_spmd()</span></a> finishes. It is primarily used by the ebsp memory inspector and should not be needed. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cb</span></code>: A function pointer to the callback function</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="epiphany">
<h4>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id1">
<h5>bsp_begin<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_beginv">
<span id="_CPPv29bsp_beginv"></span><span id="bsp_begin"></span><span class="target" id="e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"></span>void <code class="descname">bsp_begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_beginv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Denotes the start of a BSP program. </p>
<p>This initializes the BSP system on the core.</p>
<p>Must be called before calling any other BSP function. Should only be called once in a program. </p>
</dd></dl>

</div>
<div class="section" id="id2">
<h5>bsp_end<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv37bsp_endv">
<span id="_CPPv27bsp_endv"></span><span class="target" id="e__bsp_8h_1ad794334e180b711537499871020a76fe"></span>void <code class="descname">bsp_end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Denotes the end of a BSP program. </p>
<p>Finalizes and cleans up the BSP program. No other BSP functions are allowed to be called after this function is called.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Must be followed by a return statement in your main function if you want to call <code class="docutils literal notranslate"><span class="pre">ebsp_spmd()</span></code> multiple times. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id3">
<h5>bsp_nprocs<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310bsp_nprocsv">
<span id="_CPPv210bsp_nprocsv"></span><span class="target" id="e__bsp_8h_1a8980a3403ba99114626b34492b13c1cd"></span>int <code class="descname">bsp_nprocs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the number of Epiphany cores currently in use. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An integer indicating the number of cores on which the program runs. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-pid">
<h5>bsp_pid<a class="headerlink" href="#bsp-pid" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv37bsp_pidv">
<span id="_CPPv27bsp_pidv"></span><span id="bsp_pid"></span><span class="target" id="e__bsp_8h_1a1e4f897e62f8b20a7f57cc5488bfb8c8"></span>int <code class="descname">bsp_pid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv37bsp_pidv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the processor identifier of the local core. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An integer with the id of the core The processor id is an integer in the range [0, .., <a class="reference internal" href="index.html#e__bsp_8h_1a8980a3403ba99114626b34492b13c1cd"><span class="std std-ref">bsp_nprocs()</span></a> - 1]. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-time">
<h5>bsp_time<a class="headerlink" href="#bsp-time" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_timev">
<span id="_CPPv28bsp_timev"></span><span id="bsp_time"></span><span class="target" id="e__bsp_8h_1a6ee4e522d55605dc51db6ea33c06c3c2"></span>float <code class="descname">bsp_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv38bsp_timev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the time in seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a> was called. </p>
<p><p>The native Epiphany timer does not support time differences longer than </p>
<code class="docutils literal notranslate"><span class="pre">UINT_MAX/(600000000)</span></code> which is roughly 7 seconds.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A floating point value with the number of elapsed seconds since the call to <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a></dd>
</dl>
</p>
<p>If you want to measure longer time intervals, we suggest you use the (less accurate) <a class="reference internal" href="index.html#e__bsp_8h_1aeb45a09e9b589b1fdc7ede2f84d612db"><span class="std std-ref">ebsp_host_time()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Using this in combination with <a class="reference internal" href="index.html#e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"><span class="std std-ref">ebsp_raw_time()</span></a> leads to unspecified behaviour, you should only use one of these in your program.</dd>
<dt><strong>Remark</strong></dt>
<dd>This uses the internal Epiphany <code class="docutils literal notranslate"><span class="pre">E_CTIMER_0</span></code> timer so the second timer can be used for other purposes. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-host-time">
<h5>ebsp_host_time<a class="headerlink" href="#ebsp-host-time" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv314ebsp_host_timev">
<span id="_CPPv214ebsp_host_timev"></span><span id="ebsp_host_time"></span><span class="target" id="e__bsp_8h_1aeb45a09e9b589b1fdc7ede2f84d612db"></span>float <code class="descname">ebsp_host_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv314ebsp_host_timev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the time in seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a> was called. </p>
<p><p>This function uses the system clock of the host to obtain the elapsed time. Because of varying amounts of latency this can be very inaccurate (its precision is in the order of milliseconds), but it supports time intervals of arbitrary length. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A floating point value with the number of seconds since <a class="reference internal" href="index.html#e__bsp_8h_1ab7077f80f8aeb6d4c0a507c6c755b520"><span class="std std-ref">bsp_begin()</span></a></dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="ebsp-raw-time">
<h5>ebsp_raw_time<a class="headerlink" href="#ebsp-raw-time" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv313ebsp_raw_timev">
<span id="_CPPv213ebsp_raw_timev"></span><span id="ebsp_raw_time"></span><span class="target" id="e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"></span>unsigned int <code class="descname">ebsp_raw_time</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv313ebsp_raw_timev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the number of clockcycles that have passed since the previous call to <a class="reference internal" href="index.html#e__bsp_8h_1a1bd7bfc11868632a4bbfb471bd717df2"><span class="std std-ref">ebsp_raw_time()</span></a>. </p>
<p><p>This function has less overhead than bsp_time.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>An unsigned integer with the number of clockcycles</dd>
</dl>
</p>
<p>Divide the number of clockcycles by 600 000 000 to get the time in seconds.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Using this in combination with <a class="reference internal" href="index.html#e__bsp_8h_1a6ee4e522d55605dc51db6ea33c06c3c2"><span class="std std-ref">bsp_time()</span></a> leads to unspecified behaviour, you should only use one of these in your program.</dd>
<dt><strong>Remark</strong></dt>
<dd>This uses the internal Epiphany <code class="docutils literal notranslate"><span class="pre">E_CTIMER_0</span></code> timer so the second timer can be used for other purposes. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-sync">
<h5>bsp_sync<a class="headerlink" href="#bsp-sync" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_syncv">
<span id="_CPPv28bsp_syncv"></span><span id="bsp_sync"></span><span class="target" id="e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"></span>void <code class="descname">bsp_sync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv38bsp_syncv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Denotes the end of a superstep, and performs all outstanding communications and registrations. </p>
<p>Serves as a blocking barrier which halts execution until all Epiphany cores are finished with the current superstep.</p>
<p>If only a synchronization is required, and you do not want the outstanding communications and registrations to be resolved, then we suggest you use the more efficient function <a class="reference internal" href="index.html#e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"><span class="std std-ref">ebsp_barrier()</span></a> </p>
</dd></dl>

</div>
<div class="section" id="ebsp-barrier">
<h5>ebsp_barrier<a class="headerlink" href="#ebsp-barrier" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv312ebsp_barrierv">
<span id="_CPPv212ebsp_barrierv"></span><span id="ebsp_barrier"></span><span class="target" id="e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"></span>void <code class="descname">ebsp_barrier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv312ebsp_barrierv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronizes cores without resolving outstanding communication. </p>
<p>This function is more efficient than <a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. </p>
</dd></dl>

</div>
<div class="section" id="bsp-push-reg">
<h5>bsp_push_reg<a class="headerlink" href="#bsp-push-reg" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv312bsp_push_regPKvKi">
<span id="_CPPv212bsp_push_regPKvKi"></span><span id="bsp_push_reg__voidCP.iC"></span><span class="target" id="e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"></span>void <code class="descname">bsp_push_reg</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>variable</em>, <em class="property">const</em> int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv312bsp_push_regPKvKi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a variable as available for remote access. </p>
<p><p>The operation takes effect after the next call to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. Only one registration is allowed in a single superstep. When a variable is registered, every core must do so.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">variable</span></code>: A pointer to the local variable </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size in bytes of the variable</li>
</ul>
</dd>
</dl>
</p>
<p>The system maintains a stack of registered variables. Any variables registered in the same superstep are identified with each other. There is a maximum number of allowed registered variables at any given time, the specific number is platform dependent. This limit will be lifted in a future version.</p>
<p>Registering a variable needs to be done before it can be used with the functions <a class="reference internal" href="index.html#e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"><span class="std std-ref">bsp_put()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, <a class="reference internal" href="index.html#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a>.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>

<span class="c1">// Get the value of the `a` variable of core 0 and save it in `b`</span>
<span class="n">bsp_get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// Save the value of `c` into the array `x` on core 0, at array location p</span>
<span class="n">bsp_put</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>In the current implementation, the parameter nbytes is ignored. In future versions it will be used to make communication more efficient. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-pop-reg">
<h5>bsp_pop_reg<a class="headerlink" href="#bsp-pop-reg" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv311bsp_pop_regPKv">
<span id="_CPPv211bsp_pop_regPKv"></span><span id="bsp_pop_reg__voidCP"></span><span class="target" id="e__bsp_8h_1aa950687e90d6e73efec25bbd8cbc6299"></span>void <code class="descname">bsp_pop_reg</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>variable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv311bsp_pop_regPKv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>De-register a variable for remote memory access. </p>
<p><p>The operation takes effect after the next call to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. The order in which the variables are popped does not matter. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">variable</span></code>: A pointer to the variable, which must have been previously registered with <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-put">
<h5>bsp_put<a class="headerlink" href="#bsp-put" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv37bsp_putiPKvPvii">
<span id="_CPPv27bsp_putiPKvPvii"></span><span id="bsp_put__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"></span>void <code class="descname">bsp_put</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv37bsp_putiPKvPvii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy data to another processor (buffered). </p>
<p><p>The data in src is copied to a buffer (currently in the inefficient external memory) at the moment bsp_put is called. Therefore the caller can replace the data in src right after bsp_put returns. When </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a> is called, the data will be transferred from the buffer to the destination at the other processor.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to the source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
<dt><strong>Remark</strong></dt>
<dd>The current implementation uses external memory which restrains the performance of this function greatly. We suggest you use <a class="reference internal" href="index.html#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a> wherever possible to ensure good performance. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-get">
<h5>bsp_get<a class="headerlink" href="#bsp-get" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv37bsp_getiPKviPvi">
<span id="_CPPv27bsp_getiPKviPvi"></span><span id="bsp_get__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"></span>void <code class="descname">bsp_get</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv37bsp_getiPKviPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy data from another processor (buffered) </p>
<p><p>No data transaction takes place until the next call to bsp_sync, at which point the data will be copied from source to destination.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The official BSP standard dictates that first all the data of all <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions is copied into a buffer, after which all the data is written to the proper destinations. This would allow one to use bsp_get to swap to variables in place. Because of memory constraints we do not comply with the standard. In our implementation. The <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions are all executed at the same time, therefore such a swap would result in undefined behaviour.</dd>
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-hpput">
<h5>bsp_hpput<a class="headerlink" href="#bsp-hpput" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_hpputiPKvPvii">
<span id="_CPPv29bsp_hpputiPKvPvii"></span><span id="bsp_hpput__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"></span>void <code class="descname">bsp_hpput</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_hpputiPKvPvii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy data to another processor, unbuffered. </p>
<p><p>The data is immediately copied into the destination at the remote processor, as opposed to bsp_put which first copies the data to a buffer. This means the programmer must make sure that the other processor is not using the destination at this moment. The data transfer is guaranteed to be complete after the next call to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to local source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-hpget">
<h5>bsp_hpget<a class="headerlink" href="#bsp-hpget" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_hpgetiPKviPvi">
<span id="_CPPv29bsp_hpgetiPKviPvi"></span><span id="bsp_hpget__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"></span>void <code class="descname">bsp_hpget</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_hpgetiPKviPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy data from another processor. </p>
<p>This function is the unbuffered version of <a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>. <p>As opposed to </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, the data is transferred immediately When <a class="reference internal" href="index.html#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a> is called. When using this function you must make sure that the source data is available and prepared upon calling. For performance reasons, communication using this function should be preferred over buffered communication.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="index.html#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-set-tagsize">
<h5>bsp_set_tagsize<a class="headerlink" href="#bsp-set-tagsize" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv315bsp_set_tagsizePi">
<span id="_CPPv215bsp_set_tagsizePi"></span><span id="bsp_set_tagsize__iP"></span><span class="target" id="e__bsp_8h_1a1f711c4d860f03a90257f6072d9e70ec"></span>void <code class="descname">bsp_set_tagsize</code><span class="sig-paren">(</span>int *<em>tag_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv315bsp_set_tagsizePi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the tag size. </p>
<p><p>Upon return, the value pointed to by tag_bytes will contain the old tag size. The new tag size will take effect in the next superstep, so that messages sent in this superstep will have the old tag size. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_bytes</span></code>: A pointer to the tag size, in bytes</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="id4">
<h5>ebsp_get_tagsize<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv316ebsp_get_tagsizev">
<span id="_CPPv216ebsp_get_tagsizev"></span><span class="target" id="e__bsp_8h_1a47cf6f4bc4ee48eddc146f52d7eb8f95"></span>int <code class="descname">ebsp_get_tagsize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Obtain the tag size. </p>
<p><p>This function gets the tag size currently in use. This tagsize remains valid until the start of the next superstep. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The tag size in bytes</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-send">
<h5>bsp_send<a class="headerlink" href="#bsp-send" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_sendiPKvPKvi">
<span id="_CPPv28bsp_sendiPKvPKvi"></span><span id="bsp_send__i.voidCP.voidCP.i"></span><span class="target" id="e__bsp_8h_1a2d79a679686a5357acc6ba936ec60017"></span>void <code class="descname">bsp_send</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>tag</em>, <em class="property">const</em> void *<em>payload</em>, int <em>nbytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv38bsp_sendiPKvPKvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Send a message to another processor. </p>
<p><p>This will send a message to the target processor, using the message passing system. The tag size can be obtained by ebsp_get_tagsize. When this function returns, the data has been copied so the user can use the buffer for other purposes. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to the tag data </li>
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size of the data payload</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-qsize">
<h5>bsp_qsize<a class="headerlink" href="#bsp-qsize" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv39bsp_qsizePiPi">
<span id="_CPPv29bsp_qsizePiPi"></span><span id="bsp_qsize__iP.iP"></span><span class="target" id="e__bsp_8h_1ae2fc27ea113832763a241d165e3ea30c"></span>void <code class="descname">bsp_qsize</code><span class="sig-paren">(</span>int *<em>packets</em>, int *<em>accum_bytes</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv39bsp_qsizePiPi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain The number of messages in the queue and the combined size in bytes of their data. </p>
<p><p>Upon return, the integers pointed to by packets and accum_bytes will hold the number of messages in the queue, and the sum of the sizes of their data payloads respectively. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">packets</span></code>: A pointer to an integer which will be overwritten with the number of messages </li>
<li><code class="docutils literal notranslate"><span class="pre">accum_bytes</span></code>: A pointer to an integer which will be overwritten with the combined number of bytes of the message data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-get-tag">
<h5>bsp_get_tag<a class="headerlink" href="#bsp-get-tag" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv311bsp_get_tagPiPv">
<span id="_CPPv211bsp_get_tagPiPv"></span><span id="bsp_get_tag__iP.voidP"></span><span class="target" id="e__bsp_8h_1a808006e4c1d86e97d8c7a761010fb9e1"></span>void <code class="descname">bsp_get_tag</code><span class="sig-paren">(</span>int *<em>status</em>, void *<em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv311bsp_get_tagPiPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the tag and size of the next message without popping the message. </p>
<p><p>Upon return, the integer pointed to by status will receive the size of the data payload in bytes of the next message in the queue. If there is no next message it will be set to -1. The buffer pointed to by tag should be large enough to store the tag. The minimum size can be obtained by calling ebsp_get_tagsize. </p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">status</span></code>: A pointer to an integer receiving the message data size in bytes. </li>
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: A pointer to a buffer receiving the message tag</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-move">
<h5>bsp_move<a class="headerlink" href="#bsp-move" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv38bsp_movePvi">
<span id="_CPPv28bsp_movePvi"></span><span id="bsp_move__voidP.i"></span><span class="target" id="e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"></span>void <code class="descname">bsp_move</code><span class="sig-paren">(</span>void *<em>payload</em>, int <em>buffer_size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv38bsp_movePvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the next message from the message queue and pop the message. </p>
<p><p>This will copy the payload and pop the message from the queue. The size of the payload can be obtained by calling </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a808006e4c1d86e97d8c7a761010fb9e1"><span class="std std-ref">bsp_get_tag()</span></a>. If <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> is smaller than the data payload then the data is truncated. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">payload</span></code>: A pointer to a buffer receiving the data payload </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer_size</span></code>: The size of the buffer</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-hpmove">
<h5>bsp_hpmove<a class="headerlink" href="#bsp-hpmove" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv310bsp_hpmovePPvPPv">
<span id="_CPPv210bsp_hpmovePPvPPv"></span><span id="bsp_hpmove__voidPP.voidPP"></span><span class="target" id="e__bsp_8h_1a932e0b8b2e82f5ee402adecee0e921dc"></span>int <code class="descname">bsp_hpmove</code><span class="sig-paren">(</span>void **<em>tag_ptr_buf</em>, void **<em>payload_ptr_buf</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv310bsp_hpmovePPvPPv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the next message, with tag, from the queue and pop the message. </p>
<p><p>This function will give the user direct pointers to the tag and data of the message. This avoids the data copy as done in </p>
<a class="reference internal" href="index.html#e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"><span class="std std-ref">bsp_move()</span></a>.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The number of bytes of the payload data</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag_ptr_buf</span></code>: A pointer to a pointer receiving the location of the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">payload_ptr_buf</span></code>: A pointer to a pointer receiving the location of the data pyaload </li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>that both tag and payload can be stored in external memory. Repeated use of these tags will lead to overall worse performance, such that <a class="reference internal" href="index.html#e__bsp_8h_1a547cac84db9a5c1d399bacfe8b2963b2"><span class="std std-ref">bsp_move()</span></a> can actually outperform this variant. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-open">
<h5>bsp_stream_open<a class="headerlink" href="#bsp-stream-open" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv315bsp_stream_openP11ebsp_streami">
<span id="_CPPv215bsp_stream_openP11ebsp_streami"></span><span id="bsp_stream_open__ebsp_streamP.i"></span><span class="target" id="e__bsp_8h_1a4afd821ffa428a5c21e4db004e2d2f2f"></span>int <code class="descname">bsp_stream_open</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, int <em>stream_id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv315bsp_stream_openP11ebsp_streami" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Open a stream that was created using <code class="docutils literal notranslate"><span class="pre">bsp_stream_create</span></code> on the host. </p>
<p><p>The first stream created by the host will have </p>
<code class="docutils literal notranslate"><span class="pre">stream_id</span></code> 0.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Nonzero if succesful.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: Pointer to an existing <code class="docutils literal notranslate"><span class="pre">bsp_stream</span></code> struct to hold the stream data. This struct can be allocated on the stack by the user. </li>
<li><code class="docutils literal notranslate"><span class="pre">stream_id</span></code>: The index of the stream. </li>
</ul>
</dd>
</dl>
</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span>bsp_stream mystream;
if( bsp_stream_open(&amp;mystream, 3) ) {
    // Get some data
    void* buffer = 0;
    bsp_stream_move_down(&amp;mystream, &amp;buffer, 0);
    // The data is now in buffer
    // Finally, close the stream
    bsp_stream_close(&amp;mystream);`
}
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function has to be called <em>before</em> performing any other operation on the stream. </dd>
<dt><strong>Remark</strong></dt>
<dd>A call to the function should always match a single call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_close</span></code>. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-close">
<h5>bsp_stream_close<a class="headerlink" href="#bsp-stream-close" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv316bsp_stream_closeP11ebsp_stream">
<span id="_CPPv216bsp_stream_closeP11ebsp_stream"></span><span id="bsp_stream_close__ebsp_streamP"></span><span class="target" id="e__bsp_8h_1acab67dc209d2b6fba1650292b97f73ff"></span>void <code class="descname">bsp_stream_close</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv316bsp_stream_closeP11ebsp_stream" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait for pending transfers to complete and close a stream. </p>
<p><p>Behaviour is undefined if </p>
<code class="docutils literal notranslate"><span class="pre">stream</span></code> is not a handle opened by <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream, opened by <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>.</li>
</ul>
</dd>
</dl>
</p>
<p>Cleans up the stream, and frees any buffers that may have been used by the stream. </p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-move-up">
<h5>bsp_stream_move_up<a class="headerlink" href="#bsp-stream-move-up" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv318bsp_stream_move_upP11ebsp_streamPKvii">
<span id="_CPPv218bsp_stream_move_upP11ebsp_streamPKvii"></span><span id="bsp_stream_move_up__ebsp_streamP.voidCP.i.i"></span><span class="target" id="e__bsp_8h_1a4678a61cc1a9eae55c55d890046410ce"></span>int <code class="descname">bsp_stream_move_up</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, <em class="property">const</em> void *<em>data</em>, int <em>data_size</em>, int <em>wait_for_completion</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv318bsp_stream_move_upP11ebsp_streamPKvii" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a local token up to a stream. </p>
<p><p>The function </p>
<em>always</em> waits for the previous token to have finished.<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes written. Zero if an error has occurred.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data to be sent up the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">data_size</span></code>: The size of the data to be sent, i.e. the size of the token. Behaviour is undefined if it is not a multiple of 8. If it is not a multiple of 8 bytes then transfers will be slow. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code>: If nonzero this function blocks untill the data is completely written to the stream. </li>
</ul>
</dd>
</dl>
</p>
<p>If <code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code> is nonzero, this function will wait untill the data is transferred. This corresponds to single buffering.</p>
<p>Alternativly, double buffering can be used as follows. Set <code class="docutils literal notranslate"><span class="pre">wait_for_completion</span></code> to zero and continue constructing the next token in a different buffer. Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">*</span> <span class="n">buf1</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">buf2</span> <span class="o">=</span> <span class="n">ebsp_malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">curbuf</span> <span class="o">=</span> <span class="n">buf1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">otherbuf</span> <span class="o">=</span> <span class="n">buf2</span><span class="p">;</span>

<span class="n">ebsp_stream</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_stream_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// open stream 0</span>
<span class="k">while</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// Fill curbuf</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">curbuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    
    <span class="c1">// Send up</span>
    <span class="n">bsp_stream_move_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="n">curbuf</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">// Use other buffer</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">curbuf</span><span class="p">,</span> <span class="n">otherbuf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buf1</span><span class="p">);</span>
<span class="n">ebsp_free</span><span class="p">(</span><span class="n">buf2</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>Behaviour is undefined if the stream was not opened using <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>. </dd>
<dt><strong>Remark</strong></dt>
<dd>Memory is transferred using the <code class="docutils literal notranslate"><span class="pre">DMA1</span></code> engine. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-move-down">
<h5>bsp_stream_move_down<a class="headerlink" href="#bsp-stream-move-down" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv320bsp_stream_move_downP11ebsp_streamPPvi">
<span id="_CPPv220bsp_stream_move_downP11ebsp_streamPPvi"></span><span id="bsp_stream_move_down__ebsp_streamP.voidPP.i"></span><span class="target" id="e__bsp_8h_1aa23b8ef4ae753261dea1a7c17c8734d1"></span>int <code class="descname">bsp_stream_move_down</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, void **<em>buffer</em>, int <em>preload</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv320bsp_stream_move_downP11ebsp_streamPPvi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Obtain the next token from a stream. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Number of bytes of the obtained chunk. If stream has finished or an error has occurred this function will return <code class="docutils literal notranslate"><span class="pre">0</span></code>.</dd>
<dt><strong>Remark</strong></dt>
<dd>Behaviour is undefined if the stream was not opened using <code class="docutils literal notranslate"><span class="pre">bsp_stream_open</span></code>. </dd>
<dt><strong>Remark</strong></dt>
<dd>Memory is transferred using the <code class="docutils literal notranslate"><span class="pre">DMA1</span></code> engine. </dd>
<dt><strong>Remark</strong></dt>
<dd>When using double buffering, the BSP system will allocate memory for the next chunk, and will start writing to it using the DMA engine while the current chunk is processed. This requires more (local) memory, but can greatly increase the overall speed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: Receives a pointer to a local copy of the next token. </li>
<li><code class="docutils literal notranslate"><span class="pre">preload</span></code>: If this parameter is nonzero then the BSP system will preload the next token asynchroneously (double buffering). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="bsp-stream-seek">
<h5>bsp_stream_seek<a class="headerlink" href="#bsp-stream-seek" title="Permalink to this headline">¶</a></h5>
<dl class="function">
<dt id="_CPPv315bsp_stream_seekP11ebsp_streami">
<span id="_CPPv215bsp_stream_seekP11ebsp_streami"></span><span id="bsp_stream_seek__ebsp_streamP.i"></span><span class="target" id="e__bsp_8h_1aac6a2e9041be25b8903b6bb7c564186e"></span>void <code class="descname">bsp_stream_seek</code><span class="sig-paren">(</span>ebsp_stream *<em>stream</em>, int <em>delta_tokens</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv315bsp_stream_seekP11ebsp_streami" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move the cursor in the stream, to change the next token to be obtained. </p>
<p><p>If </p>
<code class="docutils literal notranslate"><span class="pre">delta_tokens</span></code> is out of bounds, then the cursor will be moved to the start or end of the stream respectively. <code class="docutils literal notranslate"><span class="pre">bsp_stream_seek(i,</span> <span class="pre">INT_MIN)</span></code> will set the cursor to the start <code class="docutils literal notranslate"><span class="pre">bsp_stream_seek(i,</span> <span class="pre">INT_MAX)</span></code> will set the cursor to the end of the stream<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: The handle of the stream </li>
<li><code class="docutils literal notranslate"><span class="pre">delta_tokens</span></code>: The number of tokens to skip if <code class="docutils literal notranslate"><span class="pre">delta_tokens</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, or to go back if <code class="docutils literal notranslate"><span class="pre">delta_tokens</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>.</li>
</ul>
</dd>
</dl>
</p>
<p>Note that if <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> is used with <code class="docutils literal notranslate"><span class="pre">preload</span></code> enabled (meaning the last call to that function had <code class="docutils literal notranslate"><span class="pre">preload</span></code> enabled), then the preloaded token will not be changed, so the first call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> after this will still yield a token from the previous position. If <code class="docutils literal notranslate"><span class="pre">preload</span></code> was not enabled then the next call to <code class="docutils literal notranslate"><span class="pre">bsp_stream_move_down</span></code> will yield a token from the new position.</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>This function provides a mechanism through which chunks can be obtained multiple times. It gives you random access in the memory in the data stream. </dd>
<dt><strong>Remark</strong></dt>
<dd>This function has <code class="docutils literal notranslate"><span class="pre">O(delta_tokens)</span></code> complexity. </dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Coduin.
      Last updated on Jun 15, 2018.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>