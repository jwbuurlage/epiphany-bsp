

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-59249373-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>BSP Variables &mdash; Epiphany BSP 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Message Passing" href="mp.html" />
    <link rel="prev" title="Getting started: The Basics" href="basic.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Epiphany BSP
          

          
            
            <img src="_static/coduin_logo_small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction and Setting up</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic.html">Getting started: The Basics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">BSP Variables</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#registering-putting-and-getting">Registering, putting and getting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#variable-registration">Variable registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#putting-and-getting-values">Putting and getting values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unbuffered-communication">Unbuffered communication</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#interface-variables">Interface (Variables)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#epiphany">Epiphany</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="mp.html">Message Passing</a></li>
<li class="toctree-l1"><a class="reference internal" href="host_client.html">Communicating with the Epiphany</a></li>
<li class="toctree-l1"><a class="reference internal" href="streaming.html">Data streams</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_features.html">Other features</a></li>
</ul>
<p class="caption"><span class="caption-text">Support Library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="output.html">Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_management.html">Memory Management</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference &amp; Background</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="memory_details.html">Parallella Memory Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="bsp.html">BSP Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Epiphany BSP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>BSP Variables</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/variables.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bsp-variables">
<h1>BSP Variables<a class="headerlink" href="#bsp-variables" title="Permalink to this headline">¶</a></h1>
<div class="section" id="registering-putting-and-getting">
<h2>Registering, putting and getting<a class="headerlink" href="#registering-putting-and-getting" title="Permalink to this headline">¶</a></h2>
<p>If we want to write more interesting EBSP programs, we need to have a way to communicate between the different Epiphany cores. In EBSP communication happens in one of two ways: using message passing, which we will introduce later, or via <em>registered variables</em>. An EBSP variable exists on every processor, but does not necessarily have the same size on every Epiphany core.</p>
<div class="section" id="variable-registration">
<h3>Variable registration<a class="headerlink" href="#variable-registration" title="Permalink to this headline">¶</a></h3>
<p>We register a variable by calling <code class="docutils literal notranslate"><span class="pre">bsp_push_reg</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>Here we declare an integer <code class="docutils literal notranslate"><span class="pre">a</span></code>, and initialize it with zero. Next we <em>register</em> the variable with the BSP system, by passing its local location, and its size.</p>
<p>To ensure that all cores have registered a variable, we perform a barrier synchronisation after the registration. The Epiphany cores will halt execution until <em>every other core</em> reaches this point in the program, so it <em>synchronizes</em> the program execution between the Epiphany cores. Only <em>one variable may be declared between calls to</em> <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>!</p>
</div>
<div class="section" id="putting-and-getting-values">
<h3>Putting and getting values<a class="headerlink" href="#putting-and-getting-values" title="Permalink to this headline">¶</a></h3>
<p>Registered variables can be written to or be read from by other cores. In BSP this is referred to as <em>putting</em> something in a variable, or <em>getting</em> the value of a variable. To write for example our processor ID to the <em>next core</em> we can write:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_put</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>Let us explain this code line by line. As in the <em>Hello World</em> example, here we define <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">p</span></code> to be the processor id and the number of processors respectively. In our call to <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> we pass the following arguments (in order):</p>
<ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> of the target (i.e. the receiving) processor.</li>
<li>A pointer to the source data that we want to copy to the target processor.</li>
<li>A pointer representing a <em>registered variable</em>. Note that this pointer refers to the registered variable on the <em>sending</em> processor – the EBSP system can identify these processors such that it knows which <em>remote address</em> to write to.</li>
<li>The offset (in bytes) from which we want to start writing at the target processor.</li>
<li>The number of bytes to copy.</li>
</ol>
<p>Before we want to use a communicated value on the target processor, we need to again perform a barrier synchronisation by calling <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>. This ensures that all the outstanding communication gets resolved. After the call to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> returns, we can use the result of <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> on the target processor. The code between two consecutive calls to <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> is called a <em>superstep</em>.</p>
<p>When we receive the data, we can for example write the result to the standard output. Below we give the complete program which makes use of <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> to communicate with another processor. Here, and in the remainder of this post we will only write the code in between the calls to <code class="docutils literal notranslate"><span class="pre">bsp_begin</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_end</span></code>, the other code is identical to the code in the <em>Hello World</em> example.:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="n">bsp_put</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;received: %i&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>This results in the following output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 0
$02: received: 1
$07: received: 6
$00: received: 15
...
</pre></div>
</div>
<p>Where we have suppressed the output from the other cores. As we see we are correctly receiving the processor id of the previous cores!</p>
<p>An alternative way of communication is <em>getting</em> the value of a registered variable from a remote core. The syntax is very similar:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_get</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
</pre></div>
</div>
<p>The arguments for <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code> are:</p>
<ol class="arabic simple">
<li>The <code class="docutils literal notranslate"><span class="pre">pid</span></code> of processor we want to <em>get</em> the value from.</li>
<li>The pointer representing a registed variable.</li>
<li>The offset (in bytes) at the remote processor from which we want to start reading.</li>
<li>A pointer to the local destination.</li>
<li>The number of bytes to copy.</li>
</ol>
<p>And again, we perform a barrier synchronisation to ensure the data has been transferred. If you are familiar with concurrent programming, then you might think we are at risk of a <a class="reference external" href="https://en.wikipedia.org/wiki/Race_condition">race condition</a>! What if processor <code class="docutils literal notranslate"><span class="pre">s</span></code> reaches the <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code> statement before processor <code class="docutils literal notranslate"><span class="pre">(s</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">%</span> <span class="pre">p</span></code> has set the value for <code class="docutils literal notranslate"><span class="pre">a</span></code> equal to its process number? Do we then obtain zero? In this case, we do not have to worry – no data transfer is initialized until each core has reached <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code>. Indeed we receive the correct output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 2
$03: received: 4
$11: received: 12
$14: received: 15
...
</pre></div>
</div>
</div>
<div class="section" id="unbuffered-communication">
<h3>Unbuffered communication<a class="headerlink" href="#unbuffered-communication" title="Permalink to this headline">¶</a></h3>
<p>So far we have discussed writing to, and reading from variables using <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. These two functions are <em>buffered</em>. When calling <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> for example, the <em>current source value</em> at the time of the function call is guarenteed to be sent to the target processor, but it does not get sent until the next barrier synchronisation – so behind the scenes the EBSP library stores a copy of the data. The BSP standard was originally designed for distributed memory systems with very high latency, in which this design makes a lot of sense. On the Epiphany platform this gives a lot of unnecessary overhead since data is copied to <em>external memory</em>.</p>
<p>This problem is not unique to the Epiphany platform however. Together with the <a class="reference external" href="http://www.multicorebsp.com/">MulticoreBSP</a> which targets modern multicore processors, two additional BSP primitives were introduced that provide <em>unbuffered</em> variable communication, <code class="docutils literal notranslate"><span class="pre">bsp_hpput</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_hpget</span></code>. Here the <code class="docutils literal notranslate"><span class="pre">hp...</span></code> prefix stands for <em>high performance</em>.</p>
<p>However, although their function signatures are completely identical, these are not meant as a drop-in replacements for <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. They are unsafe in the sense that data transfer happens <em>at once</em>. This means that when using these functions you should be aware of possible race conditions – which can notoriously lead to mistakes that can be very hard to debug.</p>
<p>To facilitate writing code using only unbuffered communication we introduce a <code class="docutils literal notranslate"><span class="pre">ebsp_barrier</span></code> function that performs a barrier synchronisation without transferring any outstanding communication that has arisen from calls to <code class="docutils literal notranslate"><span class="pre">bsp_put</span></code> and <code class="docutils literal notranslate"><span class="pre">bsp_get</span></code>. Let us look at an example program using these unbuffered variants:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bsp_nprocs</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
<span class="c1">// barrier ensures b has been written to on each core</span>
<span class="n">ebsp_barrier</span><span class="p">();</span>

<span class="n">bsp_hpput</span><span class="p">((</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// barrier ensures data has been received</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="n">ebsp_message</span><span class="p">(</span><span class="s">&quot;received: %i&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
<p>When writing or reading large amounts of data in between different <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> calls, the <code class="docutils literal notranslate"><span class="pre">hp...</span></code> functions are much more efficient in terms of local memory usage (which is very valuable because of the small size) as well as running speed. However, extra care is needed to effectively synchronize between threads. For example, if we remove either the <code class="docutils literal notranslate"><span class="pre">ebsp_barrier</span></code>, or the  <code class="docutils literal notranslate"><span class="pre">bsp_sync</span></code> calls in the previous example program, there will be a race condition.</p>
<p>We test the program, and see that the output is indeed identical to before:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>$01: received: 0
$08: received: 7
$02: received: 1
$10: received: 9
...
</pre></div>
</div>
</div>
</div>
<div class="section" id="interface-variables">
<h2>Interface (Variables)<a class="headerlink" href="#interface-variables" title="Permalink to this headline">¶</a></h2>
<div class="section" id="epiphany">
<h3>Epiphany<a class="headerlink" href="#epiphany" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv312bsp_push_regPKvKi">
<span id="_CPPv212bsp_push_regPKvKi"></span><span id="bsp_push_reg__voidCP.iC"></span><span class="target" id="e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"></span>void <code class="descname">bsp_push_reg</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>variable</em>, <em class="property">const</em> int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Register a variable as available for remote access. </p>
<p><p>The operation takes effect after the next call to </p>
<a class="reference internal" href="#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. Only one registration is allowed in a single superstep. When a variable is registered, every core must do so.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">variable</span></code>: A pointer to the local variable </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The size in bytes of the variable</li>
</ul>
</dd>
</dl>
</p>
<p>The system maintains a stack of registered variables. Any variables registered in the same superstep are identified with each other. There is a maximum number of allowed registered variables at any given time, the specific number is platform dependent. This limit will be lifted in a future version.</p>
<p>Registering a variable needs to be done before it can be used with the functions <a class="reference internal" href="#e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"><span class="std std-ref">bsp_put()</span></a>, <a class="reference internal" href="#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a>, <a class="reference internal" href="#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, <a class="reference internal" href="#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a>.</p>
<p>Usage example: <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>
<span class="n">bsp_push_reg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="n">bsp_sync</span><span class="p">();</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">bsp_pid</span><span class="p">();</span>

<span class="c1">// Get the value of the `a` variable of core 0 and save it in `b`</span>
<span class="n">bsp_get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

<span class="c1">// Save the value of `c` into the array `x` on core 0, at array location p</span>
<span class="n">bsp_put</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>In the current implementation, the parameter nbytes is ignored. In future versions it will be used to make communication more efficient. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_putiPKvPvii">
<span id="_CPPv27bsp_putiPKvPvii"></span><span id="bsp_put__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a938c8add6ddc13b9bf2841d189f0027a"></span>void <code class="descname">bsp_put</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data to another processor (buffered). </p>
<p><p>The data in src is copied to a buffer (currently in the inefficient external memory) at the moment bsp_put is called. Therefore the caller can replace the data in src right after bsp_put returns. When </p>
<a class="reference internal" href="#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a> is called, the data will be transferred from the buffer to the destination at the other processor.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to the source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
<dt><strong>Remark</strong></dt>
<dd>The current implementation uses external memory which restrains the performance of this function greatly. We suggest you use <a class="reference internal" href="#e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"><span class="std std-ref">bsp_hpput()</span></a> wherever possible to ensure good performance. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv37bsp_getiPKviPvi">
<span id="_CPPv27bsp_getiPKviPvi"></span><span id="bsp_get__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"></span>void <code class="descname">bsp_get</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data from another processor (buffered) </p>
<p><p>No data transaction takes place until the next call to bsp_sync, at which point the data will be copied from source to destination.</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>The official BSP standard dictates that first all the data of all <a class="reference internal" href="#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions is copied into a buffer, after which all the data is written to the proper destinations. This would allow one to use bsp_get to swap to variables in place. Because of memory constraints we do not comply with the standard. In our implementation. The <a class="reference internal" href="#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a> transactions are all executed at the same time, therefore such a swap would result in undefined behaviour.</dd>
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv38bsp_syncv">
<span id="_CPPv28bsp_syncv"></span><span id="bsp_sync"></span><span class="target" id="e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"></span>void <code class="descname">bsp_sync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Denotes the end of a superstep, and performs all outstanding communications and registrations. </p>
<p>Serves as a blocking barrier which halts execution until all Epiphany cores are finished with the current superstep.</p>
<p>If only a synchronization is required, and you do not want the outstanding communications and registrations to be resolved, then we suggest you use the more efficient function <a class="reference internal" href="#e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"><span class="std std-ref">ebsp_barrier()</span></a> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_hpputiPKvPvii">
<span id="_CPPv29bsp_hpputiPKvPvii"></span><span id="bsp_hpput__i.voidCP.voidP.i.i"></span><span class="target" id="e__bsp_8h_1a64cbcfe4c116ab6ea04f7f7235f17965"></span>void <code class="descname">bsp_hpput</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, void *<em>dst</em>, int <em>offset</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data to another processor, unbuffered. </p>
<p><p>The data is immediately copied into the destination at the remote processor, as opposed to bsp_put which first copies the data to a buffer. This means the programmer must make sure that the other processor is not using the destination at this moment. The data transfer is guaranteed to be complete after the next call to </p>
<a class="reference internal" href="#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A pointer to local source data </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A variable location that was previously registered using <a class="reference internal" href="#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">dst</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv39bsp_hpgetiPKviPvi">
<span id="_CPPv29bsp_hpgetiPKviPvi"></span><span id="bsp_hpget__i.voidCP.i.voidP.i"></span><span class="target" id="e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"></span>void <code class="descname">bsp_hpget</code><span class="sig-paren">(</span>int <em>pid</em>, <em class="property">const</em> void *<em>src</em>, int <em>offset</em>, void *<em>dst</em>, int <em>nbytes</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy data from another processor. </p>
<p>This function is the unbuffered version of <a class="reference internal" href="#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>. <p>As opposed to </p>
<a class="reference internal" href="#e__bsp_8h_1a6c391523672f7e98ea5c8845341423ad"><span class="std std-ref">bsp_get()</span></a>, the data is transferred immediately When <a class="reference internal" href="#e__bsp_8h_1aa1b531064994c6f0ad23a3a749a64978"><span class="std std-ref">bsp_hpget()</span></a> is called. When using this function you must make sure that the source data is available and prepared upon calling. For performance reasons, communication using this function should be preferred over buffered communication.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pid</span></code>: The pid of the target processor (this is allowed to be the id of the sending processor) </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: A variable that has been previously registered using <a class="reference internal" href="#e__bsp_8h_1a9e7246704831651b6090b88731a84ca8"><span class="std std-ref">bsp_push_reg()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: A pointer to a local destination </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: The offset in bytes to be added to the remote location corresponding to the variable location <code class="docutils literal notranslate"><span class="pre">src</span></code> </li>
<li><code class="docutils literal notranslate"><span class="pre">nbytes</span></code>: The number of bytes to be copied</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Remark</strong></dt>
<dd>No warning is thrown when nbytes exceeds the size of the variable src. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv312ebsp_barrierv">
<span id="_CPPv212ebsp_barrierv"></span><span id="ebsp_barrier"></span><span class="target" id="e__bsp_8h_1aa0bf11c0e00dbd25c1595d6892366d4c"></span>void <code class="descname">ebsp_barrier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd><p>Synchronizes cores without resolving outstanding communication. </p>
<p>This function is more efficient than <a class="reference internal" href="#e__bsp_8h_1ad8dbbc296f5b775f4089b8320e7e82c1"><span class="std std-ref">bsp_sync()</span></a>. </p>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mp.html" class="btn btn-neutral float-right" title="Message Passing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="basic.html" class="btn btn-neutral" title="Getting started: The Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015-2017, Coduin.
      Last updated on Jun 16, 2018.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>